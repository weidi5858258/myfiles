Android音视频的编解码

android_atomic_inc()原子操作函数
android_atomic_add()
const_cast<RefBase*>
Android中提出了一套类似Java垃圾回收机制的智能指针，采用强指针sp（Strong Pointer）和弱指针wp（Weak Pointer）对目标对象进行应用，实现对象的自动回收。
对象可以分为全局对象、局部对象、静态全局对象和静态局部对象。
Android设计了强引用sp和弱引用wp，故实际对象的释放，可分为强引用控制和弱引用控制。所谓强引用控制，指的是强引用数mStrong为0时，释放实际对象；弱引用控制，则指的是弱引用数mWeak为0时，才释放实际对象。


// encoder
result = avcodec_send_frame(audioAVCodecContext, frame);
result = avcodec_receive_packet(audioAVCodecContext, avPacket);

// decoder
result = avcodec_send_packet(audioAVCodecContext, avPacket);
result = avcodec_receive_frame(audioAVCodecContext, decoded_frame);


cd x264
CC=cl ./configure --enable-static --enable-shared --enable-pic


 ./configure --toolchain=msvc --enable-yasm --enable-asm --enable-gpl --enable-libx264 --extra-cflags=-I/usr/local/include --extra-ldflags=-LIBPATH:/usr/local/lib



 ./configure --prefix=/root/mydev/tools/ffmpeg --enable-libmp3lame --enable-static --enable-shared --enable-x86asm --enable-asm --enable-gpl --enable-libx264


Stream #0.0[0x1e0]: Video: mpeg2video, yuv420p, 704x576 [PAR 12:11 DAR 4:3], 9578 kb/s, 25 tbr, 90k tbn, 50 tbc
25  tbr 代表帧率
90k tbn 代表文件层的时间精度,即1S=1200k,和duration相关
50  tbc 代表视频层的时间精度,即1S=50,和strem->duration和时间戳相关

在AndroidAPI <= 20（Android5.0之前的版本）中Google支持的CameraPreview Callback的YUV常用格式有两种：一个是NV21，一个是YV12。如果我们需要对Camera采集的图像进行编码等，必须要对其进一步处理，比如格式转换、旋转等操作，否则会出现一些花屏、叠影等问题。	


采样率：每秒钟记录多少个采样点；
在H264协议里定义了三种帧，完整编码的帧叫I帧，参考之前的I帧生成的只包含差异部分编码的帧叫P帧，还有一种参考前后的帧编码的帧叫B帧。
H264采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成I帧的算法，帧间压缩是生成B帧和P帧的算法。

ffmpeg提供了av_rescale_q_rnd函数进行转换。
av_rescale_q_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
此函数主要用于对于不同时间戳的转换。具体来说是将原来以 "时间基b" 表示的 数值a 转换成以 "时间基c" 来表示的新值。AVRounding表示取整的策略

ffmpeg -i /media/1.WAV -acodec libmp3lame /media/1.MP3
ffmpeg -i apple.mp4 -f mp3 -vn apple.mp3
参数解释：
-i 表示input，即输入文件
-f 表示format，即输出格式
-vn表示vedio not，即输出不包含视频
对比源视频文件和提取得到的音频文件大小，可以看到源视频文件为约23M，而提取出来的音频文件大小为3M。

FFmpeg还提供了很多有用的工具可以查看和处理音视频文件，如：
查看视频文件的音视频编解码格式，视频时长，比特率等，如下：
dennis@ubuntu:~$ ffmpeg -i apple.mp4

ffmpeg -i test.mp4 -vcodec libx264 -b:v 1200k -r 25 -acodec mp3 -ab 128k -ar 44100 output.mp4

ffmpeg -codecs
ffmpeg -codecs | grep aac

[whb@jcwkyl introduction_to_algorithm]$ ffmpeg -i Lecture_1.flv -f mp2 -vn Lecture_1.mp3
这条命令中，-i表示input file，-f表示输出格式，-vn表示“vedio not"，即禁止视频输出，最后转换后的文件是Lecture_1.mp3。
转换完成后，使用file命令查看Lecture_1.mp3的文件格式：
[whb@jcwkyl introduction_to_algorithm]$ file Lecture_1.mp3
Lecture_1.mp3: MPEG ADTS, layer II, v2,  64 kBits, 22.05 kHz, Stereo
转换前后文件大小对比：
[whb@jcwkyl introduction_to_algorithm]$ du -hs Lecture_1.*
153M    Lecture_1.flv
37M     Lecture_1.mp3
使用播放器播放Lecture_1.mp3，完全正常。



avCodec = avcodec_find_encoder_by_name("libfdk_aac");










