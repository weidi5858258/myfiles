C++基础知识

///////////////////////////零碎知识点部分///////////////////////////

静态变量(static)
外部变量(extern)
寄存器变量
自动存储变量

            具体写法                  简写形式
有符号短整型	short int           ---> short
有符号长整型	long int            ---> long（数值后面加“l”或者“L”）
无符号短整型	unsigned short int  ---> unsigned short
无符号长整型	unsigned long int   ---> unsigned long
有符号整型    signed int          ---> int
无符号整型	unsigned int        ---> unsigned

C++语言的基本数据类型
1)布尔型:
    bool
2)字符型:
    char
  双字符型:
    双字节型(wchar_t)
    宽字符型
3)整型:
    无符号型(unsigned int)
    短整型(short int)
    长整型(long int)
4)浮点型:
    单精度浮点型(float)
    双精度浮点型(double)
    长双精度浮点型(long double)

类型                         占用字节数       取值范围
bool                            1           true or false

char                            1           -128~127(256个字符)
wchar_t 			                                 256个字符

short int                       2           -32768~32767
unsigned short int                          0~65535

int                             4           -2147483648~2147483647
long int                        4           -2147483648~2147483647
unsigned int（或者unsigned）                 0~4294967295（32位系统）
unsigned long int                           0~4294967295

float                           4
double                          8
long double                     12

进程的终止方式：
1.从main返回
2.调用exit
3.调用_exit
4.调用abort
5.由一个信号终止
进程在终止的时候，系统会释放进程所拥有的资源，如内存、文件描述符、内核结构等。

进程之间的通信
进程之间的通信有多种方式，其中管道、共享内存和消息队列是最常用的方式。
1.
管道
是UNIX族中进程通信的最古老的方式，它利用内核在两个进程之间建立通道，
它的特点是与文件的操作类似，仅仅在管道的一端只读，另一端只写。
利用读写的方式在进程之间传递数据。
2.
共享内存
在多个进程之间共享,多个进程利用获得的共享内存的地址来直接对内存进行操作。
3.
消息
是在内核中建立一个链表，发送方按照一定的标识将数据发送到内核中，
内核将其放入量表后，等待接收方的请求。接收方发送请求后，
内核按照消息的标识，从内核中将消息从链表中摘下，传递给接收方。
消息是一种完全的异步操作方式。

进程之间的同步
多个进程之间需要写作完成任务时，经常发生业务之间的依赖现象，
从而出现了进程的同步问题。Linux下进程的同步方式主要有消息、信号量等。
信号量是一个共享的表示数量的值。用于多个进程之间操作或者共享资源的保护，
它是进程之间同步的最主要方式。

函数名: getenv
功  能: 从环境中取字符串,获取环境变量的值
头文件: stdlib.h
用  法: char *getenv(char *envvar);
函数说明:
getenv()用来取得参数envvar环境变量的内容。
参数envvar为环境变量的名称，如果该变量存在
则会返回指向该内容的指针。环境变量的格式为
envvar=value。
getenv函数的返回值存储在一个全局二维数组里，
当你再次使用getenv函数时不用担心会覆盖上次的调用结果。
返回值: 执行成功则返回指向该内容的指针，
找不到符合的环境变量名称则返回NULL。
如果变量存在但无关联值，它将运行成功并返回一个空字符串，
即该字符的第一个字节是null。



构造函数的作用：
1、构造对象
2、初始化对象
3、

类型不一样进行赋值时，中间必须要借助一个临时变量。
如果这个临时变量产生不了，那么这个赋值操作就会失败。
产生的中间变量的类型为赋值操作的左值的类型，
然后把右值当作这个临时变量的初始值从而生成一个中间变量，
最后把这个中间变量赋给左值。

产生随机数
#include <cstdlib>
void srand(unsigned seed)
ctime头文件中的time函数
srand(time(NULL))
chrono头文件中的std::chrono::system_clock
srand(std::chrono::system_clock::to_time_t(
        std::chrono::system_clock::now()));

cin遇到不可见字符和空字符就停止输入（不可见字符指的
是制表符和空格），而cout则只是遇到空字符才停止输出。
这就量为什么将空字符作为字符串结束标志的原因，
cin和cout遇到空字符都会结束输入和输出操作。



静态联编：编译时、运行时
动态联编：联编工作是在编译时确定的
class A
{
public:
	virtual int get()
	{
		return 0;
	}
};
class B : public A
{
	int get()
	{
		return 1;
	}
};
int main()
{
	B b;
	A* p = &b;
	cout<<p->get()<<endl;// 1
	cout<<p->A::get()<<endl;// 0
}

未测试
class A
{
public:
	int get()
	{
		return 0;
	}
};
class B : public A
{
	int get()
	{
		return 1;
	}
};
int main()
{
	B b;
	A* p = &b;
	cout<<p->get()<<endl;
	cout<<p->B::get()<<endl;
}

一个派生类对象在创建时会首先调用基类的构造函数，
然后调用该类的构造函数，一般情况下，在使用虚函数时，
我们都会将派生类对象传递给指向基类的指针，那么假如
指向派生类对象的指针删除时会发生什么情况呢？如果
析构函数是虚函数，那么就会进行正确的操作，它会先调用
派生类的析构函数，由于一般情况下任何类的析构函数都可
声明为虚析构函数，当指针被删除时，系统会获得对象运行
时的类型并调用正确的析构函数。
但是要注意三点：
1.由于析构函数不允许有参数，因此它不可能实现重载，
    那么一个类就只能有一个虚析构函数。
2.只要基类的析构函数被说明为虚函数，那么派生类的析构函数无论说明与否，
    都自然成为虚函数。
3.在C++中虚构造函数是不存在的，因此也无法声明。

dynamic_cast<son>(father)
typeid()



运算符*被称为间接引用运算符,当使用*时,就读取它后面变量中所保存的地址处的值.
概念:
指针地址:            指针自身的地址.
指针保存的地址:       指针保存的地址.
指针地址的值:         指针保存的地址处的值.



#include<stdio.h>
#include<limits.h> 整数的极限
#include<float.h>  浮点数的极限
#include<math.h>   数学
#include<stdlib.h>
#include<Windows.h>

int a1 = 10;十进制
int a2 = 010;八进制
int a3 = 0x10;十六进制
int a4 = 101u;无符号整数
int a5 = 102l;长整数
int a6 = 103ll;长长整数
int a7 = 0101u;


short int nummax = SHRT_MAX;  32767
short int nummin = SHRT_MIN; -32768
%d sizeof(short int); 2个字节
标准写法是short int, 不过int可以省略,但是最好不要省略

unsigned short nummax = USHRT_MAX; 65535
unsigned short nummin = USHRT_MIN; 0
USHRT_MAX加1后就变成0
unsigned int的极大值要大于int,但是unsigned int不能表示负数,因为最小为0

int intmax = INT_MAX;  2147483647
int intmin = INT_MIN; -2147483648
long int longmax = LONG_MAX;  2147483647
long int longmin = LONG_MIN; -2147483648
标准写法是long int, 不过int可以省略,但是最好不要省略
sizeof(int) 4个字节
sizeof(long int) 4个字节
int与long int在32位及以上的机器是等价的,都占用4个字节
在16位机器上,int与short int是等价的,都占用2个字节

LONG_MAX;   2147483647L
LONG_MIN;  -2147483647L-1
ULONG_MAX;  0xffffffffUL
LLONG_MAX;  9223372036854775807I64
LLONG_MIN; -9223372036854775807I64-1
ULLONG_MAX; 0xffffffffffffffffui64
long long phone = 18565603244; 存储QQ, phone
printf("%lld", phone);
unsigned long long max = ULLONG_MAX; 存储身份证号
printf("%llu", max); 18446744073709551615

float f1 = 10.5;
printf("%f", f);
32bits or 64bits are same.
sizeof(10.5);  8个字节 实数双精度常量 sizeof(double)
sizeof(10.5f); 4个字节 实数单精度常量 sizeof(float)
long double >= double指的是内存空间(取决于编译器)

int num = 3 / 5;
printf("%d", num); 0
num = 3.2;
printf("%d", num); 3 赋值号会自动转换类型,printf不会

float f2 = 19e8;
printf("%f", f2); 1900000000.000000
f2 = 19.3456e-25; e 10,指数只能是整数
3.14        double 8个字节 32bits 有效数字6~7位
3.14f 3.14F float  4个字节 64bits 有效数字15~16位

== 成立是1,不成立是0

float f3 = 1.0000000000001; 有效数字6~7位
float f4 = 1.0000000000000005;
priintf("%d", f3 == f4); 1

%.50f 保留小数点后50位
printf("%f, %f", FLT_MAX, FLT_MIN);
printf("%f, %f", DBL_MAX, DBL_MIN);

double S = sqrt(p*(p-a)*(p-b)*(p-c));



char ch = 'A'; 1个字节(字符常量)
wchar_t wch = L'字'; 宽字符
putchar(ch);
printf("%c", ch);
sizeof(ch);  1个字节
sizeof('A'); 4个字节(为了兼容和拓展宽字符,一般情况下占4个字节)
sizeof(wch); 2个字节

system("color 4f");
system("title weidi");
system("pause");

printf("%d", sizeof(""));  1个字节
printf("%d", sizeof("A")); 2个字节(字符串/0结束,等于每个字符,尾部加上'\0')
printf("%d", sizeof("节")); 2个字节,再加结束符1个

字符串不能作用于单个字符
1
'1'
0    %d 48 %c 0
'0'  %d 0  %c 空字符
'\0' %d 0  %c 空字符

int num = 1;
char ch = '1';
printf("%d, %d", sizeof(num), sizeof(ch)); 4 1 内存大小不一样
printf("%d", ch); 屏幕上输出的这个字符对应的整数,相当于求ASCCII码,ASCCII码就是整数
printf("%c", ch); 打印字符,是个字符1,不是数字1
printf("%d", num); 打印数字1
printf("%c", num); 打印数字1对应的字符
char ch1 = '\0';
char ch2 = '0';
char ch3 = 0; ch1与ch3是等价的
int num = 0;
printf("%d,%d,%d", sizeof(ch1), sizeof(ch2), sizeof(num));
printf("\n%d", ch1); '\0'的编号是0
printf("\n[%c]", ch1); '\0'空字符
printf("\n%d", ch2); 48
printf("\n%c", ch2); 0  求字符本身
printf("\n%d", ch3);
printf("\n%c", ch3);

getchar(); 等待
putchar(ch);

char str[5] = {'c','a','3','e','@'};
system(str);//windows下打开计算器
printf("%s", str);
char str[100] = {0};
sprintf(str,"color %c%c" ,'5','e');
system(str);
char str[100] = {0};
sprintf(str, "title %s的杰作", "weidi");
system(str);

int a;
&a; ok
&&a; error

const int a = 10;
int *p = 100;
printf("a = %d\n", a);

const int a; int const a; // same
int *const p;
const int *const p;

const int a; // c can this
const int a = 100; // c++ must this

char *p = malloc(100); // c can this
char *p = malloc(100); // c++ cann't this
char *p = (char*)malloc(100);

#include<iostream>
std::cout<<"...\t";
std::cout<<"...\n";
std::cout<<std::endl;
"endl"与"\n"的区别是前者不仅有后者的功能,还有调用输出流的flush的功能.
std::是个命名空间标识符,C++标准库中的函数或者对象都是在命名空间std中定义的,
所以我们要使用的标准库中的函数或者对象都要用std来限定.
使用标准库文件iostream时,要写上std;使用非标准库文件iostream.h时,则不用写.
如果在使用标准库文件iostream时,不喜欢重复地使用std,
我们可以使用一种类似通告的形式来告诉编译器我们将使用标准库函数cout和endl.
在方法中这样使用:
using std::cout;
using std::endl;
cout<<"...\t";
cout<<endl;
另外一种方式是(也在方法中使用):
using namespace std;
iostream.h是C语言格式的,iostream是C++语言格式的

在程序中使用函数时,必须先声明它然后再定义,
声明的目的是告诉编译器即将要定义的函数的名字是什么,
返回值的类型是什么以及参数是什么.
而定义则是告诉编译器这个函数的功能是什么.
假如不声明,那么该函数就不能被其他函数调用.
通常我们把函数声明叫做函数原型,而把函数定义叫函数实现.

面向对象: 抽象,封装,继承,多态

//内联函数:把这个函数的所有代码复制到调用处,这样程序执行时不用来回跳转
inline int func(int);
在不知道具体怎么操作时,最好先不要使用内联函数.
等完成程序的大部分功能时,再对符合要求的函数进行内联操作.
将类中的函数声明和函数定义合并在一起时,该函数会自动成为内联函数.

#include <stdio.h>
char buf[10] = {10,10,10,10,10,10,10,10,10,10};
FILE *fp = fopen("c:\\test.dat","w");
fwrite(buf,1,10,fp);
fclose(fp);
FILE *fp1 = fopen("c:\\test1.dat","wb");
fwrite(buf,1,10,fp);
fclose(fp1);
我们注意到，程序的第一段定义一个数组，每个分量的值为：10,等价的十六进制为0A。
第二段，先是打开一个文件test.dat进行写操作，再是把10个数据写入文件，最后关闭文件。
第三段，功能差不多，只是文件名换成了test1.dat,打开文件的模式换成了wb.
第二段和第三段有什么区别呢？我们看一下最后的文件内容：
test.dat:  0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A 0D 0A
test1.dat： 0A 0A 0A 0A 0A 0A 0A 0A 0A 0A
原因是为什么呢？这就是w 和 wb的区别，
w是以文本方式打开文件，wb是二进制方式打开文件，
以文本方式打开文件时，fwrite函数每碰到一个0x0A时，
就在它的前面加入0x0D.其它内容不做添加操作。
r 以只读方式打开文件，该文件必须存在。
　　r+ 以可读写方式打开文件，该文件必须存在。
　　rb+ 读写打开一个二进制文件，只允许读写数据。
　　rt+ 读写打开一个文本文件，允许读和写。
　　w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
　　w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
　　a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）
　　a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）
　　wb 只写打开或新建一个二进制文件；只允许写数据。
　　wb+ 读写打开或建立一个二进制文件，允许读和写。
　　wt+ 读写打开或着建立一个文本文件；允许读写。
　　at+ 读写打开一个文本文件，允许读或在文本末追加数据。
　　ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。
　　上述的形态字符串都可以再加一个b字符，如rb、w+b或ab＋等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在POSIX系统，包含Linux都会忽略该字符。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask 值

判断文件夹是否存在：
在windows环境下头文件为：
#include <io.h>
在linux环境下头文件为：
#include <unistd.h>
int access(const char* _Filename, int _AccessMode)
上述函数在windows和linux环境下均可使用
该函数功能为确定文件或文件夹的访问权限，如果指定的访问权限有效，则函数返回0，否则返回-1
Filename可以是文件路径，也可以是文件夹路径，可以使用绝对路径或相对路径
_AccessMode表示要验证的文件访问权限，有可读、可写、可执行以及是否存在四种权限，当Filename表示文件夹时仅能查询文件夹是否存在
_AccessMode：
头文件unistd.h中有如下定义：
    #define R_OK 4 /* Test for read permission. */
    #define W_OK 2 /* Test for write permission. */
    #define X_OK 1 /* Test for execute permission. */
    #define F_OK 0 /* Test for existence. */
    具体含义如下：
    R_OK 只判断是否有读权限
    W_OK 只判断是否有写权限
    X_OK 判断是否有执行权限
    F_OK 只判断是否存在
    在宏定义里面分别对应：
    00 只存在
    02 写权限
    04 读权限
    06 读和写权限
_AccessMode=00表示只判断是否存在
_AccessMode=02表示文件是否可执行
_AccessMode=04表示文件是否可写
_AccessMode=06表示文件是否可读

创建新的文件夹:
windows环境下头文件为:
#include <direct.h>
函数原型为：
int mkdir(const char *_Path)
该函数功能为建立一个新的目录，创建成功则返回0，否则返回-1
_Path：新建文件夹路径，可使用绝对路径，可也用相对路径
windows环境下也可用函数_mkdir:
_mkdir(const char *_Path)
默认mode是0777，表示最大可能的访问权
linux环境下头文件为:
    #include <sys/types.h>
    #include <sys/stat.h>
函数原型为：
int mkdir(const char *pathname, mode_t mode);
该函数功能为创建一个新的目录，并指定它的执行权限。如果创建成功则返回0，否则，返回-1
S_IRWXU
00700权限，代表该文件所有者拥有读，写和执行操作的权限
S_IRUSR(S_IREAD)
00400权限，代表该文件所有者拥有可读的权限
S_IWUSR(S_IWRITE)
00200权限，代表该文件所有者拥有可写的权限
S_IXUSR(S_IEXEC)
00100权限，代表该文件所有者拥有执行的权限
S_IRWXG
00070权限，代表该文件用户组拥有读，写和执行操作的权限
S_IRGRP
00040权限，代表该文件用户组拥有可读的权限
S_IWGRP
00020权限，代表该文件用户组拥有可写的权限
S_IXGRP
00010权限，代表该文件用户组拥有执行的权限
S_IRWXO
00007权限，代表其他用户拥有读，写和执行操作的权限
S_IROTH
00004权限，代表其他用户拥有可读的权限
S_IWOTH
00002权限，代表其他用户拥有可写的权限
S_IXOTH
00001权限，代表其他用户拥有执行的权限
可叠加使用，如0755表示S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH。表示该文件所有者拥有读，写和执行操作权限去，该文件用户组拥有可读，可执行的权限，其他用户拥有可读，可执行的权限。 

删除文件夹：
windows环境下头文件：
#include <direct.h>
linux环境下头文件：
#include <dirent.h>
函数原型为：
int rmdir(const char *_Path)
函数功能是删除参数指定的文件夹，成功返回0，否则返回-1
在windows环境下也可使用函数_rmdir


///////////////////////////模板///////////////////////////

模板部分
templeate<typename Type>
typeid(Type).name()

用于方法
template<typename T> 
T sum(T a, T b);
用于类
template<typename T1, typename T2>
class Point
{
private:
	T1 x;
	T2 y;
public:
	Point(T1 _x, T2 _y): x(_x), y(_y){}
	T1 getX();
	void setX(T1 x);
	T2 getY();
	void setY(T2 y);
};
举例子:
template<class T>
swap(T &rx, T &ry) {
    T temp = rx;
    rx = ry;
    ry = temp;
}

///////////////////////////字符串///////////////////////////

美帝 窄字符
天朝 宽字符

#include <string>
#include <string.h>
using namespace std;

空字符串的ASCLL为32，而空字符（空格）的ASCLL为0。
' ' == 32
cin.get（str， 1000）能接收空格。
char name[] = {'a','b',32,'c',0,'\0'};
后面要自己添加上'\0'，这样字符数组才能转化成字符串。
char name[] = {"abc efg"};
后面不需要自己再添加'\0'。
strlen(name):不包括不可见字符（不可见：结束符）
sizeof(name):包括不可见字符
strcmp(ch1, ch2)
不能把一个数组名赋给另一个数组名
strcpy(ch1, ch2)把ch2赋给ch1
strcpy函数会将ch2中的所有字符，包括结束标志'\0'一块复制到ch1中去
str1.assign(str2, 3, 1)
strcat(ch1, ch2)
下面几个函数都是计算字符串的可见长度
strlen(str1.c_str())
str1.size()
str1.length()

strncat(ch1, ch2, 5)
str1.append(str2, 5, 3)

string a("c++");
string b(a);
string c(4, 'a');
cout<<a<<endl;//c++
cout<<b<<endl;//c++
cout<<c<<endl;//aaaa
string s1;
string s2(s1);
cout<<s1<<endl;//空行
cout<<s2<<endl;//空行

字符串是以空字符结尾的字符数组.
"\0"是一个空字符标志,它的ASCII码为0.
哪些是空字符呢:
1.
空格

char man[12];
cin>>man;
cin.get(man, 12);
cin.get的结束标志是"\n",也就是换行,因此语句遇到空格不会结束,
而是把空格也看做一个字符.
cout遇到空字符(不带单引号的0或者带单引号的\0)就会停止输出.

//在初始化数组大小时,如果小于12,那么会报error
char man[12] = {"hello world"};
//hello world
cout<<man<<endl;
//11可见字符长度,不包括\0
cout<<"strlen(man): "<<strlen(man)<<endl;
//12数组定义多大就是多大,如果没有定义,那么结果为可见字符长度加上\0
cout<<"sizeof(man): "<<sizeof(man)<<endl;
man[5]='\0';
//hello
cout<<man<<endl;
//5
cout<<"strlen(man): "<<strlen(man)<<endl;
//12
cout<<"sizeof(man): "<<sizeof(man)<<endl;

char型字符串是C语言风格的字符串,它是用数组来保存字符串的.
在C++风格中,就是string字符串.
使用:
using std::string声明一次
std::string在各个地方都这样使用

字符数组与字符对象的不同点:
1.
string str = "string";
char ch[] = "char";
if (str == "string") {
    //成立
}
if (ch == "char") {
    //不成立(正确做法是需要对字符数组中的每个元素进行比较)
}
if (strcmp(ch, "pig") == 0) {
    //成立
}

string型字符串的赋值(直接赋值或者使用assign函数)
char型字符串无法直接赋值,如:
char ch1[] = "give me";
char ch2[] = "a cup";
ch1 = ch2;//error
不能将一个数组名直接赋给另一个数组名.
但是可以使用strcpy函数来实现赋值的目的.如:
char ch1[100] = "what ";
char ch2[] = "my name is Jack";
cout<<sizeof(ch1)<<endl;
cout<<sizeof(ch2)<<endl;
strcpy(ch1, ch2);
cout<<ch1<<endl;
cout<<ch2<<endl;
cout<<sizeof(ch1)<<endl;
cout<<sizeof(ch2)<<endl;
总结:
只要ch1的大小足够放得下ch2的字符个数,那么程序没有问题.
但是如果ch1的大小小于ch2的字符个数,虽然程序也执行了,
而且没有报错,但是程序会卡住一会儿,然后程序返回时又是一个非正常值,
因此需要保证ch1的大小要大于等于ch2的字符个数.
strcpy会将ch2中的所有字符,包括结束标志"\0"一起复制到ch1中去.

string类具有自动调节字符串大小的功能.
string str1 = " gh ";
string str2 = "q abcdef ";
str1.assign(str2, 9, 1);
cout<<str1<<endl;
str2有9个字符,不包括"\0".
9表示从str2中第9个位置(从0开始),取出1个字符赋值给str1,
因此str1的结果是个空格.
assign函数中的第2个参数不能超出str2的可见字符个数,不能编译出错.

string型字符串的合并(直接使用加法运算)
对两个char型字符串进行合并要用到strcat函数,strcat函数将第2个字符串合并
到第1个字符串,因此第1个字符串必须保证能容纳两个字符串的长度.
char ch1[] = "what't your name? ";
char ch2[] = "my name is Jack.";
strcat(ch1, ch2);
//what't your name? my name is Jack.
cout << ch1 << endl;
string型字符串的合并实例:
string str1 = "what't your name? ";
string str2 = "my name is Jack.";
str1 = str1 + str2;
cout << str1 << endl;
cout<<str1.size()<<endl;
cout<<str1.length()<<endl;
string对象调用size()和length()的结果是相同的,都是计算不包括"\0"的可见字符.
length()是早期版本的string类中的成员,而size()则是以后添加进行的,为的是兼容STL.
C++的字符串合并比C语言的字符串合并更方便有效,而且不易产生错误.

string型字符串的部分合并(使用append函数)
C语言提供了strncat函数来实现对char型字符串的部分合并,或者说部分复制.
char ch1[100] = "what't your name? ";
char ch2[] = "my name is Jack.";
strncat(ch1, ch2, 4);
//what't your name? my n
cout << ch1 << endl;
4表示从ch2中取前4个字符,然后接到ch1中去.
string类append成员函数的使用实例:
string str1 = "what't your name? ";
string str2 = "my name is Jack.";
str1.append(str2, 4, 2);
//what't your name? am
cout << str1 << endl;
4表示从str2的第4个位置(从0开始)开始,取2个字符接到str1中去.

string型字符串的替换(使用replace函数)
如果想用一个char型字符串中的几个字符替换掉另一个char型字符串,
可以使用C库中的strncpy函数.
char ch1[100] = "what't your name? ";
char ch2[] = "my name is Jack.";
strncpy(ch1, ch2, 4);
//my n't your name?
cout << ch1 << endl;
4表示从ch2中取前4个字符,把ch1中的前4个字符替换掉,其他的不变.
string类自带了一个替换函数replace,该函数可以被重载,它的参数有多种.

string型字符串的复制
char型字符串的复制.如:
char ch1[100] = "what't your name? ";
char ch2[] = "my name is Jack.";
memmove(ch1, ch2, 10);
//my name isr name?
cout << ch1 << endl;
效果跟strncpy函数一样.
string型字符串复制到char型字符串的copy函数.
string str1 = "what't your name? ";
char ch1[] = "12345";
int n = str1.copy(ch1, 4, 1);
//hat'5
cout << ch1 << endl;
4表示从str1的字符串中+复制4个字符,1表示从第1个位置(从0开始)开始,
然后把ch1的前4个字符覆盖掉.

string型字符串的插入(使用insert函数)
string str1 = "what't your name? ";
string str2 = "my name is Jack.";
str1.insert(2, str2, 0, 4);
//whmy nat't your name?
cout << str1 << endl;
从str2的第0个位置开始取4个字符,然后插入到str1中第2个位置的后面.

string型字符串的删除(使用erase函数)
string类的成员函数erase()可以根据指定的字符串中的位置,删除字符串中的字符,
同时返回指向下一个字符的this指针.
string str1 = "what't your name? ";
str1.erase(8, 2);
//what't yr name?(把第8个字符的后面2个字符给删除掉)
cout << str1 << endl;
str1.erase(5);
//what'(把第5个字符后面的所有字符给删除掉)
cout << str1 << endl;
str1.erase();
//把剩下的全部给删除掉了,因为位置默认从0开始
cout << str1 << endl;

string型字符串的查找(使用find函数)






///////////////////////////STL///////////////////////////

vector<typename T> c;
c.at(index);
c.front();
c.back();
c[index];
c.push_back(obj);

迭代器相关的函数：
begin容器中第一个元素
end最后一个元素的下一个位置
rbegin逆向迭代器的第一个元素
rend逆向迭代器的最后一个元素的下一个元素

find():Temlpate<class InputIterator, class T> inline
find_if():Temlpate<class InputIterator, class T, class Predicate> inline

for_each(c.begin(), c.end(), print);
Vector<int>::iterator location_index;
location_index = find(c.begin(), c.end(), 5);
location_index = find_if(c.begin(), c.end(), bind2nd(greater<int>(), 5));

STL的组成构件
STL的组件中最主要的是容器、迭代器、算法和仿函数。
容器:用来管理某类对象的集合
迭代器:用来在一个对象群集的元素上进行遍历动作
算法:用来处理群集内的元素

标准模板库：
1.容器：
1-1.顺序容器
vector：从后面快速的插入与删除，直接访问任何元素
deque：从前面或后面快速的插入与删除，直接访问任何元素
list：双链表，从任何地方快速插入与删除
#include <vector>
#include <deque>
#include <list>
vector<string> vt;
deque<int> dq;
list<student> lt;
C<T> c:创建一个名为c的容器，容器类型为C，如vector
或list，T为容器内元素的类型。适用于所有容器。
C c2(c)：创建一个c容器的副本，c2和c必须具有相同的容器类型和元素类型，适用于所有容器。
C c(b, e)：创建一个名为c的容器，元素是迭代器b，
e标示范围内的副本，适用于所有容器。
C c(n, t)：创建一个名为c的容器，元素为
n个个数，值为t，t的类型必须是容器C的元素类型或可以转换为该类型，只适用于顺序容器。
C c(n):创建一个名为c的容器，元素为n个初始化元素的值，元素类型为值n的类型，只适用于顺序容器。

函数：
a)begin和end
返回容器的迭代器，通过迭代器我们可以访问容器内的元素。
std::vector<int>::iterator iter = c.begin();
c.begin();
c.end();
c.rebegin();
c.rend();

b)添加元素
c.push_back():在容器尾部添加值为t的元素，
返回void。
c.push_front()：在容器头部添加值为t的元素，
返回void，只适用于list和deque。
c.insert(p, t)：在迭代器p所指向的元素前面插入
值为t的元素，返回指向t的迭代器。
c.insert(p, n, t)：在迭代器p所指向的元素前面插入
n个值为t的元素，返回void。
c.insert(p, b, e)：在迭代器p所指向的元素前面插入
由迭代器b和e标记的范围内的元素，返回void。

c)获得容器大小
c.size()：返回容器内元素个数，
返回类型为c::size_type。
c.max_size()：返回容器内最多可容纳的元素个数，
返回类型为c::size_type。
c.empty()：测试容器内是否有元素。
c.resize()：重新调整容器大小，使其能容纳n个元素。
c.resize(n, t)：重新调整容器大小，逾期能容纳n个
元素，新添加元素以值t进行初始化。

d)访问容器元素
c.front()：返回容器内第一个元素的引用，如果c为
空，该操作未定义。
c.back()：返回容器内最后一个元素的引用，如果c为
空，该操作未定义。
c[n] at方法：返回下标为n的引用，n越界时，该操作
未定义，只用于vector和deque。

e)删除元素
c.erase(p)：删除迭代器p指向的元素，返回一个指向
被删除元素后面的元素的迭代器。
c.erase(b, e)：删除迭代器b和e标记范围内的所有
元素，返回一个指向被删除元素段后面的元素的
迭代器。
c.clear()：删除容器内的所有元素，返回void。
c.pop_front()：删除容器的第一个元素，返回void，只
适用于list和deque。
c.pop_back()：删除容器的最后一个元素，返回void。

f)赋值操作
c1 = c2：删除c1的所有元素，将c2的所有元素复制
给c1，c1和c2的容器类型及元素类型必须相同。
c1.swap(c2)：交换c1和c2中的所有元素，c1和c2的容器
类型及元素类型必须相同。
c.assign(b, e)：重新给c赋值，内容为b和e所标记范围内
的元素，b和e必须不是指向c中的元素的迭代器。
c.assign(n, t)：将c中的元素重新调转为n个值为t的
元素。

1-2.关联容器
set：快速查找，不允许有重复的值
    //没有multiset这样的头文件
    multiset：快速查找，允许有重复的值
map：一对多映射，基于关键字快速查找，不允许有重复的值
    //没有multimap这样的头文件
    multimap：一对多映射，基于关键字快速查找，允许有重复的值

1-3.容器适配器
stack：先进后出
queue：先进先出
    //没有priority_queue这样的头文件
    priority_queue：最高优先级元素，问题第一个出列

2、迭代器
3、算法
4、仿函数

///////////////////////////





















































Android.mk:
可执行文件,动态库,静态库
Jar包,APK

LOCAL_PATH:Android.mk文件所在的目录
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE := test
LOCAL_SRC_FILES := test.c

使用系统提供的函数添加源文件到Android.mk中
LOCAL_C_ALL_FILES := $(call all-c-files-under)
LOCAL_SRC_FILES := $(LOCAL_C_ALL_FILES)

LOCAL_MODULE_PATH := $(LOCAL_PATH)
include $(BUILD_EXECUTABLE)

all-c-files-under函数
build/core/definitions.mk

cat external/test/test.c
mmm external/test/
build/core/definitions.mk环境变量的配置文件
build/core/config.mk
build/core/main.mk
build/core/clear_vars.mk





























































