java基础知识


android基础知识
A->B1->B2->B3->B4->B5->A
Intent intent = new Intent(B5.this, A.class);   
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);// FLAG的使用
startActivity(intent);

<activity android:name=".SingleTastActivtiy" android:label="singleTask launchmode" android:launchMode="signleTask" android:taskAffinity="">

FLAG_ACTIVITY_NEW_TASK
使用一个新的Task来启动一个Activity，但启动的每个Activity都讲在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。
FLAG_ACTIVITY_SINGLE_TOP
使用singletop模式启动一个Activity，与指定android：launchMode=“singleTop”效果相同。
FLAG_ACTIVITY_CLEAR_TOP
使用SingleTask模式来启动一个Activity，与指定android：launchMode=“singleTask”效果相同。
FLAG_ACTIVITY_NO_HISTORY
Activity使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。


android动画

android有关View的知识

android


请描述一下Android的事件分发机制?
https://blog.csdn.net/kingda008/article/details/88077503
https://blog.csdn.net/qq_32534441/article/details/103634329?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&spm=1001.2101.3001.4242
事件分发的对象是谁？
答：用户的点击事件（Touch事件）
Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象
即当一个点击事件（MotionEvent ）产生后，系统需把这个事件传递给一个具体的 View 去处理。
事件分发的本质?
答：将点击事件（MotionEvent）传递到某个具体的View进行处理的整个过程.
事件在哪些对象之间进行传递？
答：Activity、ViewGroup、View
事件分发的顺序?
答：事件传递的顺序：Activity -> ViewGroup -> View
事件分发过程由哪些方法协作完成？
答：dispatchTouchEvent(),onInterceptTouchEvent()和onTouchEvent().
简要的谈谈Android的事件分发机制？
当点击事件发生时，首先Activity将TouchEvent传递给Window，再从Window传递给顶层View。TouchEvent会最先到达最顶层 view 的 dispatchTouchEvent ，然后由 dispatchTouchEvent 方法进行分发，如果dispatchTouchEvent返回true ，则整个事件将会被销毁，如果dispatchTouchEvent返回 false ，则交给上层view的 onTouchEvent 方法来开始处理这个事件，如果 interceptTouchEvent 返回 true ，也就是拦截掉了，则交给自身的 onTouchEvent 来处理，如果 interceptTouchEvent 返回 false ，那么事件将继续传递给子 view ，由子 view 的 dispatchTouchEvent 再来开始这个事件的分发。如果事件传递到某一层的子 view 的 onTouchEvent 上了，且这个方法返回了 false ，那么这个事件会从这个 view 往上传递，都是 onTouchEvent 来接收，直到onTouchEvent返回true为止。而如果传递到最顶view的 onTouchEvent 也返回 false 的话，这个事件就会消失。

A Activity 打开 B Activity 时都有哪些生命周期回调?
B launchMode standard(没有可复用的实例时)
	A.onPause -> B.onCrete -> B.onStart -> B.onResume -> A.onStop
B launchMode singleTop(已经在栈顶时)
	B.onPause -> B.onNewIntent -> B.onResume
B launchMode singleTask/singleInstance(有可复用的实例时)
	A.onPause -> B.onNewIntent -> B.onRestart -> B.onStart -> B.onResume -> A.onStop -> ( 如果 A 被移出栈的话还有一个 A.onDestory)

onActivityResult 在哪两个生命周期之间回调？
从 B Activity 返回 A Activity 的生命周期调用为：
B.onPause -> A.onActivityResult -> A.onRestart -> A.onStart -> A.onResume

弹出Dialog对生命周期有什么影响？
生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView 显示的（没有经过 AMS），所以不会对生命周期有任何影响。
如果是启动一个 Theme 为 Dialog 的 Activity, 则生命周期为：
A.onPause -> B.onCrete -> B.onStart -> B.onResume




Padding是控件的内容相对控件的边缘的边距，而Margin是控件边缘相对于其他控件的边距。
字体使用sp，宽高使用dp
Touch事件分发中只有两个主角:ViewGroup和View。
ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。
View包含dispatchTouchEvent、onTouchEvent两个相关事件。

https://blog.csdn.net/yh_coco/article/details/79427595
Activity的LaunchMode
	standard 模式
	这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。
	singleTop 模式
	如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。
	singleTask 模式
	如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。
	singleInstance 模式
	在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。
理解Activity，View,Window三者关系
	1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。
	2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。
	3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等
	4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。

Android中的几种动画
	帧动画
	帧动画是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源，他的原理就是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。在有些代码中，我们还会看到android：oneshot="false"，这个oneshot的含义就是动画执行一次（true）还是循环执行多次。
	 <?xml version="1.0" encoding="utf-8"?>
	  <animation-list xmlns:android="http://schemas.android.com/apk/res/android">
	      <item
	          android:drawable="@drawable/a_0"
	          android:duration="100" />
	      <item
	          android:drawable="@drawable/a_1"
	          android:duration="100" />
	      <item
	          android:drawable="@drawable/a_2"
	          android:duration="100" />
	  </animation-list>
	补间动画又可以分为四种形式，分别是alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。
	补间动画的实现，一般会采用xml文件的形式；代码会更容易书写和阅读，同时也更容易复用。Interpolator主要作用是可以控制动画的变化速率 ，就是动画进行的快慢节奏。pivot决定了当前动画执行的参考位置
	<?xml version="1.0" encoding="utf-8"?>
	  <set xmlns:android="http://schemas.android.com/apk/res/android"
	  android:interpolator="@[package:]anim/interpolator_resource"
	  android:shareInterpolator=["true" | "false"] >
	      <alpha
	         android:fromAlpha="float"
	         android:toAlpha="float" />
	      <scale
	         android:fromXScale="float"
	         android:toXScale="float"
	         android:fromYScale="float"
	         android:toYScale="float"
	         android:pivotX="float"
	         android:pivotY="float" />
	      <translate
	          android:fromXDelta="float"
	          android:toXDelta="float"
	          android:fromYDelta="float"
	          android:toYDelta="float" />
	     <rotate
	          android:fromDegrees="float"
	          android:toDegrees="float"
	          android:pivotX="float"
	          android:pivotY="float" />
	     <set>
	          ...
	     </set>
	  </set>
	属性动画
	属性动画，顾名思义它是对于对象属性的动画。因此，所有补间动画的内容，都可以通过属性动画实现。属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。

一条最长的短信息约占多少byte?
中文70(包括标点)，英文160，160个字节。



内存溢出 out of memory：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。内存溢出通俗的讲就是内存不够用。
内存泄露 memory leak  ：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光

Context
	ContextImpl: 功能实现者
	ContextWrapper: ContextThemeWrapper,Service,Application

DTS与PTS
	PTS就是Presentation Time Stamp也就说这个帧什么时候会放在显示器上;
	DTS就是Decode Time Stamp，就是说这个帧什么时候被放在编码器去解。
	在没有B帧的情况下，DTS和PTS的输出顺序是一样的。

比特率
	比特率表示经过编码（压缩）后的音、视频数据每秒钟需要用多少个比特来表示。
	比特率也叫做码率  
	也就是指每秒传送的比特(bit)数。
	比如音频的比特率：比特率 =采样率 x 采用位数 x声道数。

影响视频清晰度的指标
	帧率
	码率
	分辨率
	量化参数（压缩比）
影响视频流畅度的指标
	码率
	帧率

什么是GOP
	GOP ( Group of Pictures ) 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位。
	也就是说GOP组是指一个关键帧I帧所在的组的长度，每个 GOP 组只有 1 个 I 帧。
	GOP 组的长度格式也决定了码流的大小。
	GOP越大，中间的P帧和B帧的数量就越多，所以解码出来的视频质量就越高，但是会影响编码效率。

如何保存activity的状态？
	默认情况下activity的状态系统会自动保存，有些时候需要我们手动调用保存。
	当activity处于onPause，onStop之后，activity处于未活动状态，但是activity对象却仍然存在。当内存不足，onPause，onStop之后的activity可能会被系统摧毁。
	当通过返回退出activity时，activity状态并不会保存。
	保存activity状态需要重写onSavedInstanceState()方法，在执行onPause,onStop之前调用onSavedInstanceState方法，onSavedInstanceState需要一个Bundle类型的参数，我们可以将数据保存到bundle中，通过实参传递给onSavedInstanceState方法。
	Activity被销毁后，重新启动时，在onCreate方法中，接受保存的bundle参数，并将之前的数据取出。

如何自定义LayoutManager
	1.public RecyclerView.LayoutParams generateDefaultLayoutParams() {...}	
	2.public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {...}
	3.public boolean canScrollVertically() {...}
	4.public boolean canScrollHorizontally() {...}
	5.public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {...}
	6.public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) {...}

equal比较的是两个字符串的值是否相等，而==比较的是两个对象的内存地址是否相等

String、StringBuffer与StringBuilder之间的区别
	1.String含义为引用数据类型, 是字符串常量.是不可变的对象,(显然线程安全)在每次对string类型进行改变的时候其实都等同与生成了一个新的String对象.然后指针指向新的String对象,所以经常改变内容的字符串最好不使用String,因为每次生成对象都会对系统性能产生影响,特别当内存中无引用对象多了之后.JVM的垃圾回收(GC)就会开始工作,对系统的性能会产生影响.
    2.StringBuffer 线程安全的可变字符序列:对StringBuffer对象本身进行操作,而不是生成新的对象.所以在改变对象引用条件下,一般推荐使用StringBuffer.同时主要是使用append和insert方法,
    3.StringBuilder 线程不安全的可变字符序列.提供一个与StringBuffer兼容的API,但不同步.设计作为StringBuffer的一个简易替换,用在字符缓冲区被单个线程使用的时候.效率比StringBuffer更快.
    区别:
	    a.执行速度:StringBuilder > StringBuffer > String
	    b.线程安全:StringBuffer线程安全.StringBuilder线程不安全
	    c.String适用与少量字符串操作
	      StringBuilder适用于单线程字符缓冲区下进行大量字符操作的情况
	      StringBuffer适用于多线程字符缓冲区进行大量字符操作的情况

View(一个Button点击后,最先被调用的就是这个dispatchTouchEvent方法)
	public boolean dispatchTouchEvent(MotionEvent event) {
	    if (mOnTouchListener != null 
		    && (mViewFlags & ENABLED_MASK) == ENABLED 
		    && mOnTouchListener.onTouch(this, event)) {
	        return true;
	    }
	    return onTouchEvent(event);
	}
	// onTouch ---> onTouchEvent ---> onClick(在onTouchEvent中被触发)

View invalidate方法+postInvalidate方法
在UI主线程中，用invalidate()；本质是调用View的onDraw()绘制.
主线程之外，用postInvalidate().
postInvalidate()方法可以在UI线程执行，也可以在工作线程执行。而invalidate()只能在UI线程操作。但是从重绘速率讲：invalidate()效率高。
当View的appearance发生改变，比如状态改变（enable，focus），背景改变，隐显改变等，这些都属于appearance范畴，都会引起invalidate操作.
所以当我们改变了View的appearance，需要更新界面显示，就可以直接调用invalidate方法.
View（非容器类）调用invalidate方法只会重绘自身，ViewGroup调用则会重绘整个View树.

View绘制分三个步骤，顺序是：onMeasure，onLayout，onDraw。经代码亲测，log输出显示：调用invalidate方法只会执行onDraw方法；调用requestLayout方法只会执行onMeasure方法和onLayout方法，并不会执行onDraw方法。
当我们进行View更新时，若仅View的显示内容发生改变且新显示内容不影响View的大小、位置，则只需调用invalidate方法；若View宽高、位置发生改变且显示内容不变，只需调用requestLayout方法；若两者均发生改变，则需调用两者，按照View的绘制流程，推荐先调用requestLayout方法再调用invalidate方法。


































