java基础知识


android基础知识
A->B1->B2->B3->B4->B5->A
Intent intent = new Intent(B5.this, A.class);   
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);// FLAG的使用
startActivity(intent);

<activity android:name=".SingleTastActivtiy" android:label="singleTask launchmode" android:launchMode="signleTask" android:taskAffinity="">

FLAG_ACTIVITY_NEW_TASK
使用一个新的Task来启动一个Activity，但启动的每个Activity都讲在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。
FLAG_ACTIVITY_SINGLE_TOP
使用singletop模式启动一个Activity，与指定android：launchMode=“singleTop”效果相同。
FLAG_ACTIVITY_CLEAR_TOP
使用SingleTask模式来启动一个Activity，与指定android：launchMode=“singleTask”效果相同。
FLAG_ACTIVITY_NO_HISTORY
Activity使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。


android动画
逐帧动画(Frame Animation) 加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间
补间动画(Tween Animation) Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。
属性动画(Property Animation) 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了

ObjectAnimator.ofObject(view, "position", new PointEvaluator(), pStart, pEnd);
	第一个参数：动画的实施对象
	第二个参数：关键词， 在动画的实施对象中必须要有一个 "set关键词()"的方法，该关键词也是动画实施对象的一个属性。比如某view有一个setColor()方法,"color"为某view的一个属性。在动画实施过程中，会不停的调用这个set方法给该属性赋新的值。
	第三个参数：补间器， 实现TypeEvaluator接口，实现evaluate方法，在方法中给出属性改变的具体实现过程，以达到预期动画效果。这个步骤是整个属性动画的精髓所在，它反映了属性变化的具体过程，也是我们程序员施展自己才华的地方！
	第四个参数：属性集合，即属性的开始点，中途变化点，结束点的具体值。是在evaluate方法中计算属性值变化的依据数据。(evaluate方法中有两个参数，一头一尾，如果这里刚好也两个参数则一一对应，但是多个的情况暂时没搞清楚)。
旋转动画：
	ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f);  
	animator.setDuration(5000);  
	animator.start();
x轴平移动画：
	float curTranslationX = textview.getTranslationX();  
	ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "translationX", curTranslationX, -500f, curTranslationX);  
	animator.setDuration(5000);  
	animator.start();
缩放动画：
	ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "scaleY", 1f, 3f, 1f);  
	animator.setDuration(5000);  
	animator.start();
透明度动画：
	ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f);
	animator.setDuration(5000);  
	animator.start();
组合动画：
	ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, "translationX", -500f, 0f);  
	ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f);  
	ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f);  
	AnimatorSet animSet = new AnimatorSet();  
	animSet.play(rotate).with(fadeInOut).after(moveIn);  
	animSet.setDuration(5000);  
	animSet.start();

android有关View的知识

android


请描述一下Android的事件分发机制?
https://blog.csdn.net/kingda008/article/details/88077503
https://blog.csdn.net/qq_32534441/article/details/103634329?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&spm=1001.2101.3001.4242
事件分发的对象是谁？对什么东西进行事件分发?
答：用户的点击事件（Touch事件）
Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象
即当一个点击事件（MotionEvent ）产生后，系统需把这个事件传递给一个具体的 View 去处理。
事件分发的本质?
答：将点击事件（MotionEvent）传递到某个具体的View进行处理的整个过程.
事件在哪些对象之间进行传递？
答：Activity、ViewGroup、View
事件分发的顺序?
答：事件传递的顺序：Activity -> ViewGroup -> View
事件分发过程由哪些方法协作完成？
答：dispatchTouchEvent(),onInterceptTouchEvent()和onTouchEvent().
简要的谈谈Android的事件分发机制？
当点击事件发生时，首先Activity将TouchEvent传递给Window，再从Window传递给顶层View。TouchEvent会最先到达最顶层 view 的 dispatchTouchEvent ，然后由 dispatchTouchEvent 方法进行分发，如果dispatchTouchEvent返回true ，则整个事件将会被销毁，如果dispatchTouchEvent返回 false ，则交给上层view的 onTouchEvent 方法来开始处理这个事件，如果 interceptTouchEvent 返回 true ，也就是拦截掉了，则交给自身的 onTouchEvent 来处理，如果 interceptTouchEvent 返回 false ，那么事件将继续传递给子 view ，由子 view 的 dispatchTouchEvent 再来开始这个事件的分发。如果事件传递到某一层的子 view 的 onTouchEvent 上了，且这个方法返回了 false ，那么这个事件会从这个 view 往上传递，都是 onTouchEvent 来接收，直到onTouchEvent返回true为止。而如果传递到最顶view的 onTouchEvent 也返回 false 的话，这个事件就会消失。

A Activity 打开 B Activity 时都有哪些生命周期回调?
B launchMode standard(没有可复用的实例时)
	A.onPause -> B.onCrete -> B.onStart -> B.onResume -> A.onStop
B launchMode singleTop(已经在栈顶时)
	A.onPause -> B.onNewIntent -> B.onResume
B launchMode singleTask/singleInstance(有可复用的实例时)
	A.onPause -> B.onNewIntent -> B.onRestart -> B.onStart -> B.onResume -> A.onStop -> ( 如果 A 被移出栈的话还有一个 A.onDestory)

onActivityResult 在哪两个生命周期之间回调？
从 B Activity 返回 A Activity 的生命周期调用为：
B.onPause -> A.onActivityResult -> A.onRestart -> A.onStart -> A.onResume -> B.onStop -> B.onDestroy

弹出Dialog对生命周期有什么影响？
生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView 显示的（没有经过 AMS），所以不会对生命周期有任何影响。
如果是启动一个 Theme 为 Dialog 的 Activity, 则生命周期为：
A.onPause -> B.onCrete -> B.onStart -> B.onResume




Padding是控件的内容相对控件的边缘的边距，而Margin是控件边缘相对于其他控件的边距。
字体使用sp，宽高使用dp
Touch事件分发中只有两个主角:ViewGroup和View。
ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。
View包含dispatchTouchEvent、onTouchEvent两个相关事件。

https://blog.csdn.net/yh_coco/article/details/79427595
Activity的LaunchMode
	standard 模式
	这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。
	singleTop 模式
	如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。
	singleTask 模式
	如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，为了使该实例处在栈顶，会把这个实例上面所有的Activity都移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。
	singleInstance 模式
	在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。
理解Activity，View,Window三者关系
	1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。
	2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。
	3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等
	4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。

Android中的几种动画
	帧动画
	帧动画是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源，他的原理就是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。在有些代码中，我们还会看到android：oneshot="false"，这个oneshot的含义就是动画执行一次（true）还是循环执行多次。
	 <?xml version="1.0" encoding="utf-8"?>
	  <animation-list xmlns:android="http://schemas.android.com/apk/res/android">
	      <item
	          android:drawable="@drawable/a_0"
	          android:duration="100" />
	      <item
	          android:drawable="@drawable/a_1"
	          android:duration="100" />
	      <item
	          android:drawable="@drawable/a_2"
	          android:duration="100" />
	  </animation-list>
	补间动画又可以分为四种形式，分别是alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。
	补间动画的实现，一般会采用xml文件的形式；代码会更容易书写和阅读，同时也更容易复用。Interpolator主要作用是可以控制动画的变化速率 ，就是动画进行的快慢节奏。pivot决定了当前动画执行的参考位置
	<?xml version="1.0" encoding="utf-8"?>
	  <set xmlns:android="http://schemas.android.com/apk/res/android"
	  android:interpolator="@[package:]anim/interpolator_resource"
	  android:shareInterpolator=["true" | "false"] >
	      <alpha
	         android:fromAlpha="float"
	         android:toAlpha="float" />
	      <scale
	         android:fromXScale="float"
	         android:toXScale="float"
	         android:fromYScale="float"
	         android:toYScale="float"
	         android:pivotX="float"
	         android:pivotY="float" />
	      <translate
	          android:fromXDelta="float"
	          android:toXDelta="float"
	          android:fromYDelta="float"
	          android:toYDelta="float" />
	     <rotate
	          android:fromDegrees="float"
	          android:toDegrees="float"
	          android:pivotX="float"
	          android:pivotY="float" />
	     <set>
	          ...
	     </set>
	  </set>
	属性动画
	属性动画，顾名思义它是对于对象属性的动画。因此，所有补间动画的内容，都可以通过属性动画实现。属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。

一条最长的短信息约占多少byte?
中文70(包括标点)，英文160，160个字节。



内存溢出 out of memory：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。内存溢出通俗的讲就是内存不够用。
内存泄露 memory leak  ：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光

Context
	ContextImpl: 功能实现者
	ContextWrapper: ContextThemeWrapper,Service,Application

DTS与PTS
	PTS就是Presentation Time Stamp也就说这个帧什么时候会放在显示器上;
	DTS就是Decode Time Stamp，就是说这个帧什么时候被放在编码器去解。
	在没有B帧的情况下，DTS和PTS的输出顺序是一样的。

比特率
	比特率表示经过编码（压缩）后的音、视频数据每秒钟需要用多少个比特来表示。
	比特率也叫做码率  
	也就是指每秒传送的比特(bit)数。
	比如音频的比特率：比特率 =采样率 x 采用位数 x声道数。

影响视频清晰度的指标
	帧率
	码率
	分辨率
	量化参数（压缩比）
影响视频流畅度的指标
	码率
	帧率

什么是GOP
	GOP ( Group of Pictures ) 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位。
	也就是说GOP组是指一个关键帧I帧所在的组的长度，每个 GOP 组只有 1 个 I 帧。
	GOP 组的长度格式也决定了码流的大小。
	GOP越大，中间的P帧和B帧的数量就越多，所以解码出来的视频质量就越高，但是会影响编码效率。

如何保存activity的状态？
	默认情况下activity的状态系统会自动保存，有些时候需要我们手动调用保存。
	当activity处于onPause，onStop之后，activity处于未活动状态，但是activity对象却仍然存在。当内存不足，onPause，onStop之后的activity可能会被系统摧毁。
	当通过返回退出activity时，activity状态并不会保存。
	保存activity状态需要重写onSavedInstanceState()方法，在执行onPause,onStop之前调用onSavedInstanceState方法，onSavedInstanceState需要一个Bundle类型的参数，我们可以将数据保存到bundle中，通过实参传递给onSavedInstanceState方法。
	Activity被销毁后，重新启动时，在onCreate方法中，接受保存的bundle参数，并将之前的数据取出。

如何自定义LayoutManager
	1.public RecyclerView.LayoutParams generateDefaultLayoutParams() {...}	
	2.public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {...}
	3.public boolean canScrollVertically() {...}
	4.public boolean canScrollHorizontally() {...}
	5.public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {...}
	6.public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) {...}

equal比较的是两个字符串的值是否相等，而==比较的是两个对象的内存地址是否相等

String、StringBuffer与StringBuilder之间的区别
	1.String含义为引用数据类型, 是字符串常量.是不可变的对象,(显然线程安全)在每次对string类型进行改变的时候其实都等同与生成了一个新的String对象.然后指针指向新的String对象,所以经常改变内容的字符串最好不使用String,因为每次生成对象都会对系统性能产生影响,特别当内存中无引用对象多了之后.JVM的垃圾回收(GC)就会开始工作,对系统的性能会产生影响.
    2.StringBuffer 线程安全的可变字符序列:对StringBuffer对象本身进行操作,而不是生成新的对象.所以在改变对象引用条件下,一般推荐使用StringBuffer.同时主要是使用append和insert方法,
    3.StringBuilder 线程不安全的可变字符序列.提供一个与StringBuffer兼容的API,但不同步.设计作为StringBuffer的一个简易替换,用在字符缓冲区被单个线程使用的时候.效率比StringBuffer更快.
    区别:
	    a.执行速度:StringBuilder > StringBuffer > String
	    b.线程安全:StringBuffer线程安全.StringBuilder线程不安全
	    c.String适用与少量字符串操作
	      StringBuilder适用于单线程字符缓冲区下进行大量字符操作的情况
	      StringBuffer适用于多线程字符缓冲区进行大量字符操作的情况

View(一个Button点击后,最先被调用的就是这个dispatchTouchEvent方法)
	public boolean dispatchTouchEvent(MotionEvent event) {
	    if (mOnTouchListener != null 
		    && (mViewFlags & ENABLED_MASK) == ENABLED 
		    && mOnTouchListener.onTouch(this, event)) {
	        return true;
	    }
	    return onTouchEvent(event);
	}
	// onTouch ---> onTouchEvent ---> onClick(在onTouchEvent中被触发)

View invalidate方法+postInvalidate方法
在UI主线程中，用invalidate()；本质是调用View的onDraw()绘制.
主线程之外，用postInvalidate().
postInvalidate()方法可以在UI线程执行，也可以在工作线程执行。而invalidate()只能在UI线程操作。但是从重绘速率讲：invalidate()效率高。
当View的appearance发生改变，比如状态改变（enable，focus），背景改变，隐显改变等，这些都属于appearance范畴，都会引起invalidate操作.
所以当我们改变了View的appearance，需要更新界面显示，就可以直接调用invalidate方法.
View（非容器类）调用invalidate方法只会重绘自身，ViewGroup调用则会重绘整个View树.

View绘制分三个步骤，顺序是：onMeasure，onLayout，onDraw。经代码亲测，log输出显示：调用invalidate方法只会执行onDraw方法；调用requestLayout方法只会执行onMeasure方法和onLayout方法，并不会执行onDraw方法。
当我们进行View更新时，若仅View的显示内容发生改变且新显示内容不影响View的大小、位置，则只需调用invalidate方法；若View宽高、位置发生改变且显示内容不变，只需调用requestLayout方法；若两者均发生改变，则需调用两者，按照View的绘制流程，推荐先调用requestLayout方法再调用invalidate方法。

RecyclerView和ListView的区别
RecyclerView可以完成ListView,GridView的效果，还可以完成瀑布流的效果。同时还可以设置列表的滚动方向（垂直或者水平）； RecyclerView中view的复用不需要开发者自己写代码，系统已经帮封装完成了。 RecyclerView可以进行局部刷新。 RecyclerView提供了API来实现item的动画效果。
在性能上： 如果需要频繁的刷新数据，需要添加动画，则RecyclerView有较大的优势。 如果只是作为列表展示，则两者区别并不是很大。

RecyclerView局部刷新是什么意思?


RecyclerView对数据源的操作
	//刷新所有	
	public final void notifyDataSetChanged();
	//position数据发生了改变，那调用这个方法，就会回调对应position的onBindViewHolder()方法了
	public final void notifyItemChanged(int position);
	//刷新从positionStart开始itemCount数量的item了（这里的刷新指回调onBindViewHolder()方法）
	public final void notifyItemRangeChanged(int positionStart, int itemCount);
	//在第position位置被插入了一条数据的时候可以使用这个方法刷新，注意这个方法调用后会有插入的动画，这个动画可以使用默认的，也可以自己定义
	public final void notifyItemInserted(int position);
	//从fromPosition移动到toPosition为止的时候可以使用这个方法刷新
	public final void notifyItemMoved(int fromPosition, int toPosition);
	//批量添加
	public final void notifyItemRangeInserted(int positionStart, int itemCount);
	//第position个被删除的时候刷新，同样会有动画
	public final void notifyItemRemoved(int position);
	//批量删除
	public final void notifyItemRangeRemoved(int positionStart, int itemCount);

RecyclerView中使用notifyItemRangeChanged(int positionStart, int itemCount)时闪屏；
原因
闪烁主要由于RecyclerView使用的默认的动画导致的，所以解决的方法就是修改默认的动画。
屏蔽动画方法
（1）DefaultItemAnimator继承自SimpleItemAnimator，里面有个方法是：
只要设置为false，就可以不显示动画了，也就解决了闪烁问题。 关键代码：
((SimpleItemAnimator)recyclerView.getItemAnimator()).setSupportsChangeAnimations(false);
（2）设置动画执行时间为0来解决闪烁问题
recyclerView.getItemAnimator().setChangeDuration(0);// 通过设置动画执行时间为0来解决闪烁问题
（3）修改默认的动画
//1.定义动画类
public class NoAlphaItemAnimator extends SimpleItemAnimator {
}
//2.将DefaultItemAnimator类里的代码全部copy到自己写的动画类中，然后做一些修改。
//3.首先找到private void animateChangeImpl(final ChangeInfo changeInfo) {}方法。
//4.找到方法里这两句代码：
//去掉alpha(0)
oldViewAnim.alpha(0).setListener(new VpaListenerAdapter() {...}).start();
oldViewAnim.setListener(new VpaListenerAdapter() {...}).start();
// 去掉alpha(1)
newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).
                    alpha(1).setListener(new VpaListenerAdapter() {...}).start();
newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).
                    setListener(new VpaListenerAdapter() {...}).start();
//5.最后使用修改后的动画
recyclerView.setItemAnimator(new NoAlphaItemAnimator());

RecyclerView调用notifyDataSetChanged()方法刷新后自动滚动到顶部的问题解决办法收集
1.recyclerView.setFocusableInTouchMode(false);
2.recyclerView.setFocusable(false);
3.setHasFixedSize(true);
4.把recyclerview高度设为match_parent就解决了.....
总结Recycleview不获取焦点即可解决此问题;

以下是新增一条数据的代码：
Person person = new Person(i, "WangJie_" + i, 10 + i);
adapter.notifyItemInserted(2);
personList.add(2, person);
adapter.notifyItemRangeChanged(2, adapter.getItemCount());
如上代码：
Line2：表示在position为2的位置，插入一条数据，这个时候动画开始执行。
Line3: 表示在数据源中position为2的位置新增一条数据（其实这个才是真正的新增数据啦）。
Line4: 为什么要刷新position为2以后的数据呢？因为，在position为2的位置插入了一条数据后，新数据的position变成了2，那原来的position为2的应该变成了3，3的应该变成了4，所以2以后的所有数据的position都发生了改变，所以需要把position2以后的数据都要刷新。理论上是这样，但是实际上刷新的数量只有在屏幕上显示的position为2以后的数据而已。如果这里使用notifyDataSetChanged()来刷新屏幕上显示的所有item可以吗？结果不会出错，但是会有一个问题，前面调用了notifyItemInserted()方法后会在执行动画，如果你调用notifyDataSetChanged()刷新屏幕上显示的所有item的话，必然也会刷新当前正在执行动画的那个item，这样导致的结果是，前面的动画还没执行完，它马上又被刷新了，动画就看不见了。所以只要刷新2以后的item就可以了。

长按删除的代码如下：
adapter.notifyItemRemoved(position);
personList.remove(position);
adapter.notifyItemRangeChanged(position, adapter.getItemCount());
代码跟之前插入的代码基本一致。先通知执行动画，然后删除数据源中的数据，然后通知position之后的数据刷新就可以了。

在使用RecyclerView时，当数据更新之后，立即调用notifyDataSetChanged方法进行全局刷新，会导致图片加载闪烁。
解决方法:
1.
@Override  
public long getItemId(int position) {  
    return position;  
}
2.设置item的setHasStableIds()为true：
adapter.setHasStableIds(true);
recyclerView.setAdapter(adapter);
3.自定义TAG：
Object tag = holder.ivPirture.getTag();
if(tag==null || !tag.equals(item.songId)){
   holder.ivPirture.setTag(item.songId);
   Uri uri = Uri.parse(MessageFormat.format(Constants.URL_HEAD, String.valueOf(item.singerId)));
   holder.ivPirture.setImageURI(uri);
}

RecyclerView使用"setHasStableIds(true);"数据错乱
notifyDataSetChanged时导致图片闪烁
这个问题比较好解决，一句代码，
mRecyclerViewAdapter.setHasStableIds(true);
要注意，使用上述代码的话，Adapter中的getItemId要重写成如下，如果仍用super.getItemId(position)，数据刷新会出错。
@Override
public long getItemId(int position) {
    return position;
}

Binder机制原理
Android系统的Binder机制，是由Client,Service,ServiceManager,Binder驱动程序组成的.
其中Client，Service，ServiceManager运行在用户空间，Binder驱动程序是运行在内核空间的。
而Binder就是把这4种组件粘合在一块的粘合剂，其中核心的组件就是Binder驱动程序.
ServiceManager提供辅助管理的功能，而Client和Service正是在Binder驱动程序和ServiceManager提供的基础上实现C/S之间的通信。
其中Binder驱动程序提供设备文件/dev/binder与用户控件进行交互，
Client、Service，ServiceManager通过open和ioctl文件操作相应的方法与Binder驱动程序进行通信。
而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。
而ServiceManager是一个守护进程，用来管理Service，并向Client提供查询Service接口的能力。


Android常用算法
1.插入排序
/***
 * 插入排序
 * @param array 没有排序的数组
 * @return 从小到大排好序的数组
 */
public int[] sortInsert(int[] array){
    for(int i=1;i<array.length;i++){
        int temp = array[i];
        int j;
        for(j=i-1;j>=0 && temp<array[j]; j--){
            array[j + 1] = array[j];
        }
        array[j + 1] = temp;//插入进数组
    }
    return array;
}
2.选择排序
/***
 * 选择排序
 * @param arr 没有排序的数组
 * @return 从小到大排好序的数组
 */
public int[] sortSelect(int[] arr){
    for (int i=0;i<arr.length;i++){ //循环轮数
        int min = i; //假设最小数值对应的角标
        for (int j=i+1;j<arr.length;j++){ //每轮循环次数
            if (arr[j]<arr[min]){
                min = j;
            }
        }

        //找出最小值后,进行交换
        if (arr[i]>arr[min]){
            int temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
    }
    return arr;
}
3.冒泡排序
/***
 * 冒泡排序
 * @param arr 没有排序的数组
 * @return 从小到大排好序的数组
 */
public int[] sortBubble(int[] arr){
    for (int i=0;i<arr.length - 1;i++){
        for (int j=0;j<arr.length- 1 - i;j++){
            if (arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    return arr;
}
4.快速排序
/***
 * 快速排序
 * @param arr 未排序的数组
 * @param start 起始位置
 * @param end 结束位置
 */
public void sortQuick(int[] arr,int start,int end){
    if (start>end)return;
    int i,j,temp,t;
    i = start; //起始位 , 0
    j = end; //结束位,数组长度-1
    temp =arr[start]; // 选择数组第一位作为基准
    while(i<j){
        while(i<j && temp<=arr[j]){ //先从数组最后往前检查,当基准数小于时,j--,继续往前走,一旦大于了,就停下,执行下一个while循环
            j--;
        }

        while(i<j && temp>=arr[i]){ //从数组开始位,往后检查,当基准数大于时,i++,接着往前走,直到基准小于时候,停下, 然后执行下面交换逻辑
            i++;
        }

        //两个while循环执行完,交换两个循环停下位置的数值,交换完毕后,再接着走最外侧的大while循环,直到i>j时,跳转整个while循环,执行下面基准位的赋值逻辑
        if (i<j){
            t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    //将基准位的数值赋值给中间i和j相遇的位置
    arr[start] = arr[i];
    arr[i] = temp;
    //以上是第一轮检查,并将基准位确定出来,此时,基准位左侧都比基准数值小,右侧都比基准数大

    //递归遍历基准位置左侧的数组
    sortQuick(arr,start,j-1);
    //递归遍历基准位置右侧的数组
    sortQuick(arr,i+1,end);
}















































