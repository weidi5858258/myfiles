java基础知识
类的初始化顺序依次是？
（静态变量、静态代码块）>（变量、代码块）> 构造方法



android基础知识
A->B1->B2->B3->B4->B5->A
Intent intent = new Intent(B5.this, A.class);   
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);// FLAG的使用
startActivity(intent);// 此时就会把B1,B2,B3,B4,B5这些Activity全部弹出

<activity android:name=".SingleTastActivtiy" android:label="singleTask launchmode" android:launchMode="signleTask" android:taskAffinity="">

FLAG_ACTIVITY_NEW_TASK
使用一个新的Task来启动一个Activity，但启动的每个Activity都将在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。
FLAG_ACTIVITY_SINGLE_TOP
使用singletop模式启动一个Activity，与指定android：launchMode=“singleTop”效果相同。
FLAG_ACTIVITY_CLEAR_TOP
使用SingleTask模式来启动一个Activity，与指定android：launchMode=“singleTask”效果相同。
FLAG_ACTIVITY_NO_HISTORY
Activity使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。


android动画
逐帧动画(Frame Animation) 加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间
补间动画(Tween Animation) Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。
属性动画(Property Animation) 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了

ObjectAnimator.ofObject(view, "position", new PointEvaluator(), pStart, pEnd);
	第一个参数：动画的实施对象
	第二个参数：关键词， 在动画的实施对象中必须要有一个 "set关键词()"的方法，该关键词也是动画实施对象的一个属性。比如某view有一个setColor()方法,"color"为某view的一个属性。在动画实施过程中，会不停的调用这个set方法给该属性赋新的值。
	第三个参数：补间器， 实现TypeEvaluator接口，实现evaluate方法，在方法中给出属性改变的具体实现过程，以达到预期动画效果。这个步骤是整个属性动画的精髓所在，它反映了属性变化的具体过程，也是我们程序员施展自己才华的地方！
	第四个参数：属性集合，即属性的开始点，中途变化点，结束点的具体值。是在evaluate方法中计算属性值变化的依据数据。
	(evaluate方法中有两个参数，一头一尾，如果这里刚好也两个参数则一一对应，但是多个的情况暂时没搞清楚)。
旋转动画：
	ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f);  
	animator.setDuration(5000);  
	animator.start();
x轴平移动画：
	float curTranslationX = textview.getTranslationX();  
	ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "translationX", curTranslationX, -500f, curTranslationX);  
	animator.setDuration(5000);  
	animator.start();
缩放动画：
	ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "scaleY", 1f, 3f, 1f);  
	animator.setDuration(5000);  
	animator.start();
透明度动画：
	ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f);
	animator.setDuration(5000);  
	animator.start();
组合动画：
	ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, "translationX", -500f, 0f);  
	ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f);  
	ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f);  
	AnimatorSet animSet = new AnimatorSet();  
	animSet.play(rotate).with(fadeInOut).after(moveIn);  
	animSet.setDuration(5000);  
	animSet.start();

android有关View的知识

android


请描述一下Android的事件分发机制?
https://blog.csdn.net/kingda008/article/details/88077503
https://blog.csdn.net/qq_32534441/article/details/103634329?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&spm=1001.2101.3001.4242

事件传递的顺序：Activity->Window->DecorView->ViewGroup->View。
事件分发的对象是谁？对什么东西进行事件分发?
答：用户的点击事件（Touch事件）
Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象
即当一个点击事件（MotionEvent ）产生后，系统需把这个事件传递给一个具体的 View 去处理。
事件分发的本质?
答：将点击事件（MotionEvent）传递到某个具体的View进行处理的整个过程.
事件在哪些对象之间进行传递？
答：Activity、ViewGroup、View
事件分发的顺序?
答：事件传递的顺序：Activity -> ViewGroup -> View
事件分发过程由哪些方法协作完成？
答：dispatchTouchEvent(),onInterceptTouchEvent()和onTouchEvent().

简要的谈谈Android的事件分发机制？
当点击事件发生时，首先Activity将TouchEvent传递给Window，再从Window传递给顶层View。TouchEvent会最先到达最顶层 view 的 dispatchTouchEvent ，然后由 dispatchTouchEvent 方法进行分发，如果dispatchTouchEvent返回true ，则整个事件将会被销毁，如果dispatchTouchEvent返回 false ，则交给上层view的 onTouchEvent 方法来开始处理这个事件，如果 interceptTouchEvent 返回 true ，也就是拦截掉了，则交给自身的 onTouchEvent 来处理，如果 interceptTouchEvent 返回 false ，那么事件将继续传递给子 view ，由子 view 的 dispatchTouchEvent 再来开始这个事件的分发。如果事件传递到某一层的子 view 的 onTouchEvent 上了，且这个方法返回了 false ，那么这个事件会从这个 view 往上传递，都是 onTouchEvent 来接收，直到onTouchEvent返回true为止。而如果传递到最顶view的 onTouchEvent 也返回 false 的话，这个事件就会消失。

A Activity 打开 B Activity 时都有哪些生命周期回调?
B launchMode standard(没有可复用的实例时)
	A.onPause -> B.onCrete -> B.onStart -> B.onResume -> A.onStop
B launchMode singleTop(已经在栈顶时)
	A.onPause -> B.onNewIntent -> B.onResume
B launchMode singleTask/singleInstance(有可复用的实例时)
	A.onPause -> B.onNewIntent -> B.onRestart -> B.onStart -> B.onResume -> A.onStop -> ( 如果 A 被移出栈的话还有一个 A.onDestory)

onActivityResult 在哪两个生命周期之间回调？
从 B Activity 返回 A Activity 的生命周期调用为：
B.onPause -> A.onActivityResult -> A.onRestart -> A.onStart -> A.onResume -> B.onStop -> B.onDestroy

弹出Dialog对生命周期有什么影响？
生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView 显示的（没有经过 AMS），所以不会对生命周期有任何影响。
如果是启动一个 Theme 为 Dialog 的 Activity, 则生命周期为：
A.onPause -> B.onCrete -> B.onStart -> B.onResume




Padding是控件的内容相对控件的边缘的边距，而Margin是控件边缘相对于其他控件的边距。
字体使用sp，宽高使用dp
Touch事件分发中只有两个主角:ViewGroup和View。
ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。
View包含dispatchTouchEvent、onTouchEvent两个相关事件。

https://blog.csdn.net/yh_coco/article/details/79427595
Activity的LaunchMode
	standard 模式
	这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。
	singleTop 模式
	如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。
	singleTask 模式
	如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，为了使该实例处在栈顶，会把这个实例上面所有的Activity都移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。
	singleInstance 模式
	在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。
理解Activity，View,Window三者关系
	1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。
	2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。
	3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等
	4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。

Android中的几种动画
	帧动画
	帧动画是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源，他的原理就是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。在有些代码中，我们还会看到android：oneshot="false"，这个oneshot的含义就是动画执行一次（true）还是循环执行多次。
	 <?xml version="1.0" encoding="utf-8"?>
	  <animation-list xmlns:android="http://schemas.android.com/apk/res/android">
	      <item
	          android:drawable="@drawable/a_0"
	          android:duration="100" />
	      <item
	          android:drawable="@drawable/a_1"
	          android:duration="100" />
	      <item
	          android:drawable="@drawable/a_2"
	          android:duration="100" />
	  </animation-list>
	补间动画又可以分为四种形式，分别是alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。
	补间动画的实现，一般会采用xml文件的形式；代码会更容易书写和阅读，同时也更容易复用。Interpolator主要作用是可以控制动画的变化速率 ，就是动画进行的快慢节奏。pivot决定了当前动画执行的参考位置
	<?xml version="1.0" encoding="utf-8"?>
	  <set xmlns:android="http://schemas.android.com/apk/res/android"
	  android:interpolator="@[package:]anim/interpolator_resource"
	  android:shareInterpolator=["true" | "false"] >
	      <alpha
	         android:fromAlpha="float"
	         android:toAlpha="float" />
	      <scale
	         android:fromXScale="float"
	         android:toXScale="float"
	         android:fromYScale="float"
	         android:toYScale="float"
	         android:pivotX="float"
	         android:pivotY="float" />
	      <translate
	          android:fromXDelta="float"
	          android:toXDelta="float"
	          android:fromYDelta="float"
	          android:toYDelta="float" />
	     <rotate
	          android:fromDegrees="float"
	          android:toDegrees="float"
	          android:pivotX="float"
	          android:pivotY="float" />
	     <set>
	          ...
	     </set>
	  </set>
	属性动画
	属性动画，顾名思义它是对于对象属性的动画。因此，所有补间动画的内容，都可以通过属性动画实现。属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。

一条最长的短信息约占多少byte?
中文70(包括标点)，英文160，160个字节。



内存溢出 out of memory：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。内存溢出通俗的讲就是内存不够用。
内存泄露 memory leak  ：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光

Context
	ContextImpl: 功能实现者
	ContextWrapper: ContextThemeWrapper,Service,Application
	1、Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper。
	每一个Activity和Service以及Application的Context是一个新的ContextImpl对象。
	3、getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那也许在绝大多数情况下我们都是在Activity或者Servic中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法，getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。
	4、创建对话框时不可以用Application的context，只能用Activity的context。
	5、Context的数量等于Activity的个数 + Service的个数 +1，这个1为Application。

DTS与PTS
	PTS就是Presentation Time Stamp也就说这个帧什么时候会放在显示器上;
	DTS就是Decode Time Stamp，就是说这个帧什么时候被放在编码器去解。
	在没有B帧的情况下，DTS和PTS的输出顺序是一样的。

比特率
	比特率表示经过编码（压缩）后的音、视频数据每秒钟需要用多少个比特来表示。
	比特率也叫做码率  
	也就是指每秒传送的比特(bit)数。
	比如音频的比特率：比特率 =采样率 x 采用位数 x声道数。

影响视频清晰度的指标
	帧率
	码率
	分辨率
	量化参数（压缩比）
影响视频流畅度的指标
	码率
	帧率

什么是GOP
	GOP ( Group of Pictures ) 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位。
	也就是说GOP组是指一个关键帧I帧所在的组的长度，每个 GOP 组只有 1 个 I 帧。
	GOP 组的长度格式也决定了码流的大小。
	GOP越大，中间的P帧和B帧的数量就越多，所以解码出来的视频质量就越高，但是会影响编码效率。

如何保存activity的状态？
	默认情况下activity的状态系统会自动保存，有些时候需要我们手动调用保存。
	当activity处于onPause，onStop之后，activity处于未活动状态，但是activity对象却仍然存在。当内存不足，onPause，onStop之后的activity可能会被系统摧毁。
	当通过返回退出activity时，activity状态并不会保存。
	保存activity状态需要重写onSavedInstanceState()方法，在执行onPause,onStop之前调用onSavedInstanceState方法，onSavedInstanceState需要一个Bundle类型的参数，我们可以将数据保存到bundle中，通过实参传递给onSavedInstanceState方法。
	Activity被销毁后，重新启动时，在onCreate方法中，接受保存的bundle参数，并将之前的数据取出。

如何自定义LayoutManager
	1.public RecyclerView.LayoutParams generateDefaultLayoutParams() {...}	
	2.public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {...}
	3.public boolean canScrollVertically() {...}
	4.public boolean canScrollHorizontally() {...}
	5.public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {...}
	6.public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) {...}

equal比较的是两个字符串的值是否相等，而==比较的是两个对象的内存地址是否相等

String、StringBuffer与StringBuilder之间的区别
	1.String含义为引用数据类型, 是字符串常量.是不可变的对象,(显然线程安全)在每次对string类型进行改变的时候其实都等同与生成了一个新的String对象.然后指针指向新的String对象,所以经常改变内容的字符串最好不使用String,因为每次生成对象都会对系统性能产生影响,特别当内存中无引用对象多了之后.JVM的垃圾回收(GC)就会开始工作,对系统的性能会产生影响.
    2.StringBuffer 线程安全的可变字符序列:对StringBuffer对象本身进行操作,而不是生成新的对象.所以在改变对象引用条件下,一般推荐使用StringBuffer.同时主要是使用append和insert方法,
    3.StringBuilder 线程不安全的可变字符序列.提供一个与StringBuffer兼容的API,但不同步.设计作为StringBuffer的一个简易替换,用在字符缓冲区被单个线程使用的时候.效率比StringBuffer更快.
    区别:
	    a.执行速度:StringBuilder > StringBuffer > String
	    b.线程安全:StringBuffer线程安全.StringBuilder线程不安全
	    c.String适用与少量字符串操作
	      StringBuilder适用于单线程字符缓冲区下进行大量字符操作的情况
	      StringBuffer适用于多线程字符缓冲区进行大量字符操作的情况

View(一个Button点击后,最先被调用的就是这个dispatchTouchEvent方法)
	public boolean dispatchTouchEvent(MotionEvent event) {
	    if (mOnTouchListener != null 
		    && (mViewFlags & ENABLED_MASK) == ENABLED 
		    && mOnTouchListener.onTouch(this, event)) {
	        return true;
	    }
	    return onTouchEvent(event);
	}
	// onTouch ---> onTouchEvent ---> onClick(在onTouchEvent中被触发)

View invalidate方法+postInvalidate方法
在UI主线程中，用invalidate()；本质是调用View的onDraw()绘制.
主线程之外，用postInvalidate().
postInvalidate()方法可以在UI线程执行，也可以在工作线程执行。而invalidate()只能在UI线程操作。但是从重绘速率讲：invalidate()效率高。
当View的appearance发生改变，比如状态改变（enable，focus），背景改变，隐显改变等，这些都属于appearance范畴，都会引起invalidate操作.
所以当我们改变了View的appearance，需要更新界面显示，就可以直接调用invalidate方法.
View（非容器类）调用invalidate方法只会重绘自身，ViewGroup调用则会重绘整个View树.

View绘制分三个步骤，顺序是：onMeasure，onLayout，onDraw。经代码亲测，log输出显示：调用invalidate方法只会执行onDraw方法；调用requestLayout方法只会执行onMeasure方法和onLayout方法，并不会执行onDraw方法。
当我们进行View更新时，若仅View的显示内容发生改变且新显示内容不影响View的大小、位置，则只需调用invalidate方法；若View宽高、位置发生改变且显示内容不变，只需调用requestLayout方法；若两者均发生改变，则需调用两者，按照View的绘制流程，推荐先调用requestLayout方法再调用invalidate方法。

RecyclerView和ListView的区别
RecyclerView可以完成ListView,GridView的效果，还可以完成瀑布流的效果。同时还可以设置列表的滚动方向（垂直或者水平）； RecyclerView中view的复用不需要开发者自己写代码，系统已经帮封装完成了。 RecyclerView可以进行局部刷新。 RecyclerView提供了API来实现item的动画效果。
在性能上： 如果需要频繁的刷新数据，需要添加动画，则RecyclerView有较大的优势。 如果只是作为列表展示，则两者区别并不是很大。

RecyclerView局部刷新是什么意思?


RecyclerView对数据源的操作
	//刷新所有	
	public final void notifyDataSetChanged();
	//position数据发生了改变，那调用这个方法，就会回调对应position的onBindViewHolder()方法了
	public final void notifyItemChanged(int position);
	//刷新从positionStart开始itemCount数量的item了（这里的刷新指回调onBindViewHolder()方法）
	public final void notifyItemRangeChanged(int positionStart, int itemCount);
	//在第position位置被插入了一条数据的时候可以使用这个方法刷新，注意这个方法调用后会有插入的动画，这个动画可以使用默认的，也可以自己定义
	public final void notifyItemInserted(int position);
	//从fromPosition移动到toPosition为止的时候可以使用这个方法刷新
	public final void notifyItemMoved(int fromPosition, int toPosition);
	//批量添加
	public final void notifyItemRangeInserted(int positionStart, int itemCount);
	//第position个被删除的时候刷新，同样会有动画
	public final void notifyItemRemoved(int position);
	//批量删除
	public final void notifyItemRangeRemoved(int positionStart, int itemCount);

RecyclerView中使用notifyItemRangeChanged(int positionStart, int itemCount)时闪屏；
原因
闪烁主要由于RecyclerView使用的默认的动画导致的，所以解决的方法就是修改默认的动画。
屏蔽动画方法
（1）DefaultItemAnimator继承自SimpleItemAnimator，里面有个方法是：
只要设置为false，就可以不显示动画了，也就解决了闪烁问题。 关键代码：
((SimpleItemAnimator)recyclerView.getItemAnimator()).setSupportsChangeAnimations(false);
（2）设置动画执行时间为0来解决闪烁问题
recyclerView.getItemAnimator().setChangeDuration(0);// 通过设置动画执行时间为0来解决闪烁问题
（3）修改默认的动画
//1.定义动画类
public class NoAlphaItemAnimator extends SimpleItemAnimator {
}
//2.将DefaultItemAnimator类里的代码全部copy到自己写的动画类中，然后做一些修改。
//3.首先找到private void animateChangeImpl(final ChangeInfo changeInfo) {}方法。
//4.找到方法里这两句代码：
//去掉alpha(0)
oldViewAnim.alpha(0).setListener(new VpaListenerAdapter() {...}).start();
oldViewAnim.setListener(new VpaListenerAdapter() {...}).start();
// 去掉alpha(1)
newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).
                    alpha(1).setListener(new VpaListenerAdapter() {...}).start();
newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).
                    setListener(new VpaListenerAdapter() {...}).start();
//5.最后使用修改后的动画
recyclerView.setItemAnimator(new NoAlphaItemAnimator());

RecyclerView调用notifyDataSetChanged()方法刷新后自动滚动到顶部的问题解决办法收集
1.recyclerView.setFocusableInTouchMode(false);
2.recyclerView.setFocusable(false);
3.setHasFixedSize(true);
4.把recyclerview高度设为match_parent就解决了.....
总结Recycleview不获取焦点即可解决此问题;

以下是新增一条数据的代码：
Person person = new Person(i, "WangJie_" + i, 10 + i);
adapter.notifyItemInserted(2);
personList.add(2, person);
adapter.notifyItemRangeChanged(2, adapter.getItemCount());
如上代码：
Line2：表示在position为2的位置，插入一条数据，这个时候动画开始执行。
Line3: 表示在数据源中position为2的位置新增一条数据（其实这个才是真正的新增数据啦）。
Line4: 为什么要刷新position为2以后的数据呢？因为，在position为2的位置插入了一条数据后，新数据的position变成了2，那原来的position为2的应该变成了3，3的应该变成了4，所以2以后的所有数据的position都发生了改变，所以需要把position2以后的数据都要刷新。理论上是这样，但是实际上刷新的数量只有在屏幕上显示的position为2以后的数据而已。如果这里使用notifyDataSetChanged()来刷新屏幕上显示的所有item可以吗？结果不会出错，但是会有一个问题，前面调用了notifyItemInserted()方法后会在执行动画，如果你调用notifyDataSetChanged()刷新屏幕上显示的所有item的话，必然也会刷新当前正在执行动画的那个item，这样导致的结果是，前面的动画还没执行完，它马上又被刷新了，动画就看不见了。所以只要刷新2以后的item就可以了。

长按删除的代码如下：
adapter.notifyItemRemoved(position);
personList.remove(position);
adapter.notifyItemRangeChanged(position, adapter.getItemCount());
代码跟之前插入的代码基本一致。先通知执行动画，然后删除数据源中的数据，然后通知position之后的数据刷新就可以了。

在使用RecyclerView时，当数据更新之后，立即调用notifyDataSetChanged方法进行全局刷新，会导致图片加载闪烁。
解决方法:
1.
@Override  
public long getItemId(int position) {  
    return position;  
}
2.设置item的setHasStableIds()为true：
adapter.setHasStableIds(true);
recyclerView.setAdapter(adapter);
3.自定义TAG：
Object tag = holder.ivPirture.getTag();
if(tag==null || !tag.equals(item.songId)){
   holder.ivPirture.setTag(item.songId);
   Uri uri = Uri.parse(MessageFormat.format(Constants.URL_HEAD, String.valueOf(item.singerId)));
   holder.ivPirture.setImageURI(uri);
}

RecyclerView使用"setHasStableIds(true);"数据错乱
notifyDataSetChanged时导致图片闪烁
这个问题比较好解决，一句代码，
mRecyclerViewAdapter.setHasStableIds(true);
要注意，使用上述代码的话，Adapter中的getItemId要重写成如下，如果仍用super.getItemId(position)，数据刷新会出错。
@Override
public long getItemId(int position) {
    return position;
}

Binder机制原理
Android系统的Binder机制，是由Client,Service,ServiceManager,Binder驱动程序组成的.
其中Client，Service，ServiceManager运行在用户空间，Binder驱动程序是运行在内核空间的。
而Binder就是把这4种组件粘合在一块的粘合剂，其中核心的组件就是Binder驱动程序.
ServiceManager提供辅助管理的功能，而Client和Service正是在Binder驱动程序和ServiceManager提供的基础上实现C/S之间的通信。
其中Binder驱动程序提供设备文件/dev/binder与用户控件进行交互，
Client、Service，ServiceManager通过open和ioctl文件操作相应的方法与Binder驱动程序进行通信。
而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。
而ServiceManager是一个守护进程，用来管理Service，并向Client提供查询Service接口的能力。

onPause -> onSaveInstanceState -> onStop -> onDestroy -> onCreate -> onStart -> onRestoreInstanceState -> onResume

Android常用算法
1.插入排序
/***
 * 插入排序
 * @param array 没有排序的数组
 * @return 从小到大排好序的数组
 */
public int[] sortInsert(int[] array){
    for(int i=1;i<array.length;i++){
        int temp = array[i];
        int j;
        for(j=i-1;j>=0 && temp<array[j]; j--){
            array[j + 1] = array[j];
        }
        array[j + 1] = temp;//插入进数组
    }
    return array;
}
2.选择排序
/***
 * 选择排序
 * @param arr 没有排序的数组
 * @return 从小到大排好序的数组
 */
public class SelectionSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 总共要经过 N-1 轮比较
        for (int i = 0; i < arr.length - 1; i++) {
            int min = i;

            // 每轮需要比较的次数 N-i
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    // 记录目前能找到的最小值元素的下标
                    min = j;
                }
            }

            // 将找到的最小值和i位置所在的值进行交换
            if (i != min) {
                int tmp = arr[i];
                arr[i] = arr[min];
                arr[min] = tmp;
            }

        }
        return arr;
    }
}
3.冒泡排序
/***
 * 冒泡排序
 * @param arr 没有排序的数组
 * @return 从小到大排好序的数组
 */
public int[] sortBubble(int[] arr){
    for (int i=0;i<arr.length - 1;i++){
        for (int j=0;j<arr.length- 1 - i;j++){
            if (arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    return arr;
}
4.快速排序
/***
 * 快速排序
 * @param arr 未排序的数组
 * @param start 起始位置
 * @param end 结束位置
 */
public void sortQuick(int[] arr,int start,int end){
    if (start>end)return;
    int i,j,temp,t;
    i = start; //起始位 , 0
    j = end; //结束位,数组长度-1
    temp =arr[start]; // 选择数组第一位作为基准
    while(i<j){
        while(i<j && temp<=arr[j]){ //先从数组最后往前检查,当基准数小于时,j--,继续往前走,一旦大于了,就停下,执行下一个while循环
            j--;
        }

        while(i<j && temp>=arr[i]){ //从数组开始位,往后检查,当基准数大于时,i++,接着往前走,直到基准小于时候,停下, 然后执行下面交换逻辑
            i++;
        }

        //两个while循环执行完,交换两个循环停下位置的数值,交换完毕后,再接着走最外侧的大while循环,直到i>j时,跳转整个while循环,执行下面基准位的赋值逻辑
        if (i<j){
            t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    //将基准位的数值赋值给中间i和j相遇的位置
    arr[start] = arr[i];
    arr[i] = temp;
    //以上是第一轮检查,并将基准位确定出来,此时,基准位左侧都比基准数值小,右侧都比基准数大

    //递归遍历基准位置左侧的数组
    sortQuick(arr,start,j-1);
    //递归遍历基准位置右侧的数组
    sortQuick(arr,i+1,end);
}


设计模式
	根据创建型,结构型,行为型的特点,可以总结出24种设计模式.
	创建型:
	1. 单例设计模式
	1.1 饿汉方式
	public class Singleton {
	    private static Singleton instance = new Singleton();

	    private Singleton() {
	    }

	    // 基于 classLoader 机制，自动达到了线程安全的效果
	    public static Singleton getInstance() {
	        return instance;
	    }
	}
	1.2 懒汉方式
	public class Singleton {
	    private static Singleton instance = null;

	    private Singleton() {
	    }

	    public static synchronized Singleton getInstance() {
	        if (instance == null) {
	            instance = new Singleton();
	        }
	        return instance;
	    }
	}
	1.3 懒汉方式(双重检查加锁)
	public class Singleton {
	    private volatile static Singleton instance = null; // 注意 volatile

	    private Singleton() {
	    }

	    public static Singleton getInstance() {
	        if (instance == null) { // 初步检查：尚未实例化
	            synchronized (Singleton.class) { // 再次同步(对 Singleton.class)
	                if (instance == null) { // 确认尚未实例化
	                    instance = new Singleton();
	                }
	            }
	        }
	        return instance;
	    }
	}
	1.4 静态内部类方法(推荐)
	public class Singleton {
	    private static class InstanceHolder {
	    	// 延迟加载实例
	        private static Singleton instance = new Singleton();
	    }

	    private Singleton() {
	    }

	    public static Singleton getInstance() {
	        return InstanceHolder.instance;
	    }
	}
	2. 工厂设计模式(根据不同的类型创建不同的对象)
	3. 代理设计模式(隐藏真实的方法,用户只能调用代理方法,也就是中间过渡方法)
	4. 策略设计模式
	5. 装饰器设计模式(动态地给一个对象添加一些额外的职责)
	6. 观察者设计模式
	7. 适配器设计模式

	对象模式:单例,工厂
	行为模式:代理,策略,装饰

性能优化
	ANR: 
		多使用HandlerThread.不是UI的操作,尽量到HandlerThread里面去作.
		Activity是5秒，BroadCastReceiver是10秒，Service是20秒（均为前台）
		如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。
	内存溢出:
		1.生成Bitmap时,
		先使用BitmapFactory.Options来计算inSampleSize(图片的缩略比);
		然后使用Options的inJustDecodeBounds属性来处理加载缩略图.
		2.及时释放Bitmap,调用recycler方法.
		3.使用LruCache存储对象put(key, value).
		4.对某些东西的储存使用三级缓存(内存,本地,网络).
	内存抖动:
		避免在短时间内产生大量内存.对象使用完后,最好置为null.
	内存泄漏:
		1.注意单例中的Context对象.
		2.尽量避免Activity中设计普通的内部类,要么设计成静态内部类(如Handler,AsyncTask).
		3.Cursor,File没有及时关闭.
	UI卡顿:
		1.在UI线程中做轻微耗时操作.
		2.布局过于复杂,无法在16ms内完成渲染.
		3.同一时间动画执行的次数过多,导致CPU或GPU负载过重.
		4.View过度绘制或者说View频繁触发measure,layout操作.
		5.内存频繁触发GC.
		怎么解决:
			1.布局优化,多使用include,merge,viewstub.
			2.背景和图片的内存分配优化.
	冷启动:
		冷启动就是在启动应用前，系统中没有该应用的任何进程信息。
		热启动就是用户使用返回键退出应用，然后马上又重新启动应用。
		减少冷启动时间进行优化:
			1.减少Application和MainActivity的onCreate方法的工作量.
			2.不要让Application参与业务的操作,真的要做,也要在子线程中操作业务.
			3.不要在Application是进行耗时操作.
			4.不要以静态变量的方式在Application中保存数据.
			5.减少布局的深度.

性能优化:
	启动优化
	渲染优化
	内存优化
	网络优化
	卡顿检测与优化
	耗电优化
	安装包体积优化
	安全问题


冷启动耗时统计
ADB命令方式
在Android Studio的Terminal中输入以下命令可以查看页面的启动的时间，命令如下：

adb shell am start  -W packagename/[packagename].首屏Activity
执行完成之后，会在控制台输出如下的信息：

Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.optimize.performance/.MainActivity }
Status: ok
Activity: com.optimize.performance/.MainActivity
ThisTime: 563
TotalTime: 563
WaitTime: 575
Complete


framworks/native/cmds/servicemanager
运行的进程:/system/bin/servicemanager
binder机制运行在servicemanager进程中


C/C++
signed char  ：-128 ~ 127
unsigned char：   0 ~ 255

有做过JAI开发吗？深入到什么程度呢？
除了MVVM、MVC、MVP这些,还对其他框架有了解吗？
	MVPVM,MVI

ListView和RecyclerView的区别
	ListView的用法
		继承BaseAdapter，需要重写四个方法
		不强制使用viewholder
		可以直接使用item的点击事件
		不用单独设置分隔线
		不可以定向刷新某一条数据
	RecyclerView的用法
		继承的是Recycleview.Adapter
		必须使用viewholder,封装了view的复用
		使用布局管理器管理布局的样式（横向、竖向、网格、瀑布流布局）
		点击事件可以使用给控件设置点击事件，也可以自定义点击事件
		可以自定义绘制分隔线
		可以自定义item删除增加的动画效果
		可以定向刷新某一条数据notifyItemChanged等众多方法

Handler消息机制
	1.应用启动时,也就是ActivityThread的main方法里面，创建了Looper和MessageQueue，然后调用Looper.loop开启消息循环
	2.消息入队,通过调用handler的sendMessage方法，内部是调用MessageQueue的enqueueMessage方法，进行消息入队，入队的规制是：队列没有消息，或者要入队的消息没有设置delay，或者delay时间比队列头的消息delay时间短，则将要入队的消息放到队列头，否则就插到队列中间，需要移动链表
	3.消息循环,调用MessageQueue的next方法，循环从消息队列中取出一条消息，然后交给Handler去处理，一般是回调handleMessage方法，取不到消息就阻塞，直到下一个消息入队或者其它延时消息到时间了就唤醒消息队列

安卓触摸事件的分发机制
	1.事件传递是从Activity --- ViewGroup --- View
	2.事件传递关注的方法是dispatchTouchEvent,onInterceptTouchEvent,onTouchEvent
	3.只有ViewGroup有onInterceptTouchEvent方法,Activity和View没有onInterceptTouchEvent方法
	4.

讲一下线程池的原理
	ThreadPoolExecutor的参数意义
	    corePoolSize：线程池中核心线程数的最大值
        maximumPoolSize：线程池中能拥有最多线程数
        keepAliveTime：表示空闲线程的存活时间
        TimeUnitunit：表示keepAliveTime的单位
        workQueue：用于缓存任务的阻塞队列
        handler：表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略

安卓线程池的几种方式
	1.Executors.newCachedThreadPool()
	2.Executors.newFixedThreadPool(3)
	3.Executors.newScheduledThreadPool(5)
	4.Executors.newSingleThreadExecutor()
	不要使用以上方式去创建线程池,要用ThreadPoolExecutor去创建线程池.

用多线程的时候，当队列超过了线程数，那多线程如何处理呢？
	ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
	ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。
	ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务
	ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务

Activity的启动模式有哪些，区别是什么

内存泄漏都有哪些，如何避免
	1.非静态内部类创建静态实例造成的内存泄漏
	2.单例造成的内存泄漏
	3.线程造成的内存泄漏
	4.资源对象没关闭造成的内存泄漏
	5.Handler造成的内存泄漏

ConstraintLayout约束布局的优势
	优点
		极大程度减少布局层级
		可以实现一些其他布局管理器不能实现的样式
	缺点
	    每个被参考的控件都需要设置id

Sevice是在哪个线程中使用的

平时你开发的时候用过哪些设计模式，代理模式你是在什么情况下用到的
	1.单例设计模式
	2.工厂设计模式
	3.代理设计模式
	4.策略设计模式
	5.观察者设计模式
	6.装饰器设计模式
	7.适配器设计模式
	代理模式的优点
        隔离作用：在某些情况下，一个客户端不想或者不能直接引用一个委托对象，而代理对象可以在客户端和委托对象之间起到中介作用，其特征是代理类和委托类实现相同接口
        静态代理
            **缺点：**需要为每一个服务创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得跟着修改
        动态代理
            **优点：**降低了对业务接口的耦合度
            **缺点：**只能对接口进行代理，无法对非接口和非抽象类进行代理

哪些方式可以控制锁？
	1.synchronized
	2.Lock
	3.ReadWriteLock
		final Lock lock = new ReentrantLock();
	    final Condition condition = lock.newCondition();
	    // 上锁(用于线程的暂停)
	    lock.lock();
	    condition.signal();
	    lock.unlock();
	    // 解锁(上锁才需要解锁)
	    lock.lock();
		try {
		    condition.await();
		} catch (InterruptedException e) {
		    e.printStackTrace();
		}
		lock.unlock();
		// 上锁(用于代码同步)
		lock.lock();
	    ......
	    lock.unlock();
多线程三要素
	原子性，可见性，有序性
	如何实现线程安全?
	    保证线程安全可从多线程三特性出发：
	    - 原子性（Atomicity）：单个或多个操作时要么全部执行，要么都不执行
            - Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码
            - synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问
        - 可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
            - volatile：保证新值能立即同步到主内存，且每次使用前立即从主内存刷新；
            - synchronized：在释放锁之前会将工作内存新值更新到主存中
        - 有序性（Ordering）：程序代码按照指令顺序执行
            - volatile： 本身就包含了禁止指令重排序的语义
            - synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入

activity横竖屏平切换的时候
	android:configChanges="uiMode|keyboard|keyboardHidden|screenSize|orientation|fontScale"
	onCreate onStart onResume
	onPause onStop onSaveInstanceState onDestroy onCreate onStart onRestoreInstanceState onResume

讲一下sevice的生命周期和启动模式

你在开发过程中有遇到事件冲突处理吗？你实际是怎么解决这个冲突的？
	重写子view的dispatchTonchEvent()方法。然后在里面调用一个很好用的方法，这个方法就是：
	getParent().requestDisallowInterceptTouchEvent(boolen b),
	里面的参数如果传true表示父布局不拦截，如果传false表示父布局拦截。
	
实际开发中，有无用过自定义view
平时开发有用过跨进程通信吗






































