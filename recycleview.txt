// 线性布局  
final LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this);  
linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);  
mRecyclerView.setLayoutManager(linearLayoutManager);  
使用一个线性布局管理器，其方向设置横向，这样一个横向ListView样式的列表就出来了。

下面的情况可能需要调用一下
recyclerView.setHasFixedSize(true);
recyclerView.setChildDrawingOrderCallback(adapter);

TV上面item获得焦点
1.
<android.support.v7.widget.RecyclerView
android:layout_width="match_parent"
android:layout_height="match_parent"
android:focusable="true"/>
2.
item.xml
加上
android:focusable="true"
默认第一个item被选中
1.
mRecyclerView.setOnFocusChangeListener(new OnFocusChangeListener() {  
    @Override  
    public void onFocusChange(View v, boolean hasFocus) { 
        if(hasFocus){  
            if(mRecyclerView.getChildCount()>0){  
                mRecyclerView.getChildAt(0).requestFocus();  
            }  
        }  
    }  
});
2.
holder.itemView.setFocusable(true);  

TV上面item获得焦点后当前item能够放大，失去焦点时恢复成原样
1.
在onBindViewHolder方法中实现下面代码
RecyclerViewHolder viewHolder = (RecyclerViewHolder)holder;
viewHolder.itemView.setOnFocusChangeListener(
new View.OnFocusChangeListener(){
    public void onFocusChange(View view, boolean hasFocus){
        if(hasFocus){
            view.setBackgroundColor(getColor(R.color.darkviolet));
            ViewCompat.animate(view)
            .scaleX(1.2f).scaleY(1.2f).translationZ(1).start();
        } else {
            view.setBackgroundColor(getColor(R.color.limegreen));
            ViewCompat.animate(view)
            .scaleX(1.0f).scaleY(1.0f).start();
        }

        recyclerView.invalidate();// 关键代码
    }
});
2.
覆写下面的方法（作用是：选中的item最后更新，这样选中的item才会在其他item的上面）
View focusedChildView;
int focusViewIndex;
int focusid;
public int onGetChildDrawingOrder(int childCount, int i){
    focusedChildView = recyclerView.getFocusedChild();
    focusViewIndex = recyclerView.indexOfChild(focusedChildView);
    if(focusViewIndex == -1){
        return i;
    }
    if(focusViewIndex == i){
        focusid = i;
        return childCount - 1;
    }else if(i == childCount - 1){
        return focusid;
    }else{
        return i;
    }
}

在Adapter中调用notifyDataSetChanged()方法后会调用onBindViewHolder()方法的可见item数量的次数。意思就是如可见item有10个，那么调用notifyDataSetChanged()方法后会调用10次onBindViewHolder()方法。

RV占据焦点，RV的子View没有获取焦点
需要在RV获取焦点后手动设置下焦点：
void focusRecyclerView(boolean hasFocus) {
    if (hasFocus) {
        focusChild(false);
    }
}

void focusChild(boolean isInit) {  
    if (mRecyclerView.getChildCount() > 0) {
        mRecyclerView.getChildAt(0).requestFocus();
    }
    if (isInit) {
        mAct.setSelectPos(0);
    }
}

选中的背景问题 
在SwappingHolder的子类中复写如下方法：
public void setSelectionModeBackgroundDrawable(
    Drawable selectionModeBackgroundDrawable) {  supper.setSelectionModeBackgroundDrawable(mAct.getResources().getDrawable(R.drawable.selector_list_item_shadow));
}

下面的没有验证过
setSelection()方法，跳转到最后几个Item的问题
有个问题就是，如果总共有15张图片，最后一页展示4个图片，那么跳转到pos大于11的图片时候，焦点却在pos==11的图片位置上。所以这个时候需要手动设置下。
void fouceSelected() {
    if (mAct.getSelectPos()  <= linearLayoutManager.findLastVisibleItemPosition()
    && mAct.getSelectPos() >=linearLayoutManager.findFirstVisibleItemPosition()) {
            linearLayoutManager.findViewByPosition(mAct.getSelectPos()).requestFocus();

            int focusPos = mRecyclerView.getChildCount() + mAct.getSelectPos() - linearLayoutManager.findLastVisibleItemPosition() - 1;
            mRecyclerView.getChildAt(focusPos).requestFocus();
        }
}
获取RV当前显示的第一个控件的位置和最后一个控件显示的位置来计算出当前应该获取焦点的View的位置，把焦点交给它。